(% filter relaxRules %)

(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(gravity)
[ hole again_gravity was gpGravity ]
[ hole again_gravity no again_fly:dirs was gpItem ]
[ was again_gravity ]

(queued moves)
[ was again_move:> add snakeMove:> ]
(queued flying)
[ any:v no any:> was again_fly:>    add now_fly:v ] (reorient in a pipe corner)
[ any:^ no any:> was again_fly:>    add now_fly:^ ] (reorient in a pipe corner)
dirs [           was again_fly:dirs add now_fly:dirs ]

(appearing from spawn)
[ con:>/cut:> was again_spawn add again_fly:> playerFacing:> ]
[ was again_spawn add playerFacing:right ] (wip, what is this?)

(win level)
[ was player again_exit ] win

(end collision animation, swap tiles back)
(only for objects that don't get regenerated every turn anyway)
[ again_col ] [ was ball:offs add ball ]
dirs [ again_col ] [ was con:dirs:offs add con:dirs ]
dirs [ again_col ] [ was cut:dirs:offs add cut:dirs ]
[ was again_col ]


(----INIT----)
(do these at the start of the first turn, then never again)

(connect any snakes in level)
[ init ] [ snake no init_conBnotA/init_conAnotB init_noMoreCon cut:> add con:> | snake no init_conBnotA/init_conAnotB init_noMoreCon cut:< add con:< ]
[ init ] [ player was con:> | was con:< init_connectRules ]

(spawnpoints/meta_exit)
[ init ] [ spawnpoint/meta_exit no con:dirs cut:dirs add cut:> | no wall ]

(connect walls)
[ init ] [ wall add vs_wall_con:> ]
[ init ] [ wall was vs_wall_con:> | no wall ]

(wall edge)
[ init ] [ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]

[ init ] [ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(hole border)
[ init ] [ no hole add floor ]
[ init ] [ hole add vs_hole_edge_1:> vs_hole_edge_2:> | floor ]
[ init ] [ hole no vs_hole_edge_2:^ | was vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:^ | hole no vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:< vs_hole_edge_1:^ add vs_hole_outer_corner:^ ]
[ init ] [ hole no vs_hole_edge_1:> vs_hole_outer_corner:> | no hole add vs_hole_inner_corner:^ ]


(from a spawnpoint, the player appears)
[ init ] [ spawnpoint player add again_spawn ]

(remove markers only used for init)
[ init ] [ was init_conAnotB/init_conBnotA/init_noMoreCon ]

(remove init) 
[ was init ]



(----SET AT START OF ROUND ---)

(update group for each direction of both connections and cut ends of pipes)
[ was any:dirs ]
[ con:>/cut:> add any:> ]



(----PLAYER INPUT---)

(all moves start from within a tube)
(move to empty side starts flight, this same turn)
[ any:> was >.player add stationary.player now_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(move outside of snake starts flight, but only in backwards direction)
[ no any:dirs was >.player is vs_player:< add stationary.player now_fly:> ] [ was playerFacing:dirs add playerFacing:> ]
[ no any:dirs was >.player add stationary.player col_item:> ] sfx2

(move forward starts snake movement)
[ was >.player add stationary.player snakeMove:> ] [ was playerFacing:dirs add playerFacing:> ]

(if the player isn't at the end of a snake, block the move)
dirs [ any:> any:v was snakeMove:dirs add col_item:dirs ] sfx2
dirs [ any:> any:< was snakeMove:dirs add col_item:dirs ] sfx2



(----MOVE OBJECTS----)

( 
- a pipe end with a snakeMove moves as the head of the snake
- multiblocks and npcs in front get pushed
- the tail of the snake head follows - if it can not follow, for example because it got pushed or the head got pushed,
  the head will split.
- for any tiles that should do a normal move, collision in checked first so that ALL of them have to work out
- actual movement transfers everything in those tiles over, tile by tile
)

(remove temp markers from last time)
[ was wasMoved:dirs/wasSnakeMoved:dirs/wasItemMoved:dirs/follow:dirs/discardMove:dirs/discardFollow/checkMove:dirs/checkFollow:dirs/snakeEnd ]

(INITIAL MOVE)
(push block/ item in front)
[ snakeMove:> | snake  add push:>     ]
[ snakeMove:> | gpItem add itemPush:> ]

(SPREAD PUSH MARKERS)
(items can also push/be pushed by blocks but only if there is no opening there)
  [ snake  push:>              | snake          add push:>     ] (block to block)
+ [ snake  push:>     no any:> | gpItem         add itemPush:> ] (closed block to item outside)
+ [ gpItem itemPush:>          | gpItem         add itemPush:> ] (item to item)
+ [ gpItem itemPush:>          | snake no any:< add push:>     ] (item outside to closed block)
+ dirs [ push:dirs con:> no snakeMove:dirs | con:< add push:dirs ] (whole multiblock, except don't move snake body through head alone)
+ [ snake push:>     gpItem no any:< add itemPush:> ] (item inside pushed block)
+ [ snake itemPush:> gpItem no any:> add push:>     ] (block around pushed item)

(count item pushes as any other push from now on)
[ no snake was itemPush:> add push:> ]
[ was itemPush:> ]


(COLLISION)
[ was checkMove:dirs ]
[ push:>/snakeMove:> add checkMove:> ]

(with wall)
[ checkMove:> add collMove:> | wall ] sfx2 (collision sound)

(spread collision)
(backpropagate collision markers, these will animate with bounce)
  [ checkMove:> add collMove:> | collMove:> ]
+ dirs [ collMove:dirs con:> | con:< add collMove:dirs ]

(forward propagate stopping movement on the blocks that weren't going to be pushed anyway)
(these won't show bump anim)
[ collMove:> | checkMove:> no collMove:> add discardMove:> ]
[ discardMove:> | checkMove:> no collMove:> add discardMove:> ]
+ dirs [ discardMove:dirs con:> | con:< add discardMove:dirs ]

(remember collisions and no longer check these for conflicts, as they already won't move)
[ collMove:> add cachedColl:> del checkMove:> push:> snakeMove:> ]
[ discardMove:> del checkMove:> push:> snakeMove:> ]
[ was discardMove:dirs ]


(CONFLICTS)

(only movements that didn't collide into wall are left)
(here we handle:
  - simultanious movement into the same spot
  - objects pushed into multiple directions at once
  - pushes into a moving snake, which will split off the tail and push it, or be blocked otherwise

  note: if only the head of a moving snake is moved, the body doesn't have push markers at this point
  as it will be split anyway and shouldn't have lead to a collision with walls or further pushes that way.
)

(add follow markers inside moving snakes that point to the tile nearer to the front)
[ snakeMove:dirs add snakeEnd ]
[ con:> add follow:> snakeEnd | con:< snakeMove:dirs was snakeEnd ]
[ con:> no follow:dirs snakeMove:dirs add follow:> snakeEnd | con:< follow:dirs was snakeEnd ]
(WIP: what about a snake trying to move from both ends at once?)

(potential conflict: object pushing into a single-tile moving snake)
(if the moving snake can actually move and doesn't have its own conflict, then the object will have room to move into it.)
(the checkFollow:> markers are placed for now so this will be checked later)
(no pushing through the snake head will happen if it can escape, and neither if the checkFollow isn't working)
[ checkMove:> no con:>            add collMove:>    | snakeMove:<             add cachedConflict:> ] sfx2 (always has to collide)
[ checkMove:> no con:> collMove:> add checkFollow:> | snakeMove:>             add discardFollow ]
[ checkMove:> no con:> collMove:> add checkFollow:> | snakeMove:perpendicular add discardMove:> discardFollow ] (tail won't follow, if present)

(object pushing into tail of moving snake)
(the tail will be pushed and not follow the snake head)
[ checkMove:> no con:> | follow:dirs add discardFollow ]

(conflict at empty tile, which is moved into from multiple directions)
[ checkMove:> | no snake gpItem add wantsToMoveTo:> ]
[ wantsToMoveTo:> wantsToMoveTo:^ add cachedConflict:> cachedConflict:^ ]
[ wantsToMoveTo:> wantsToMoveTo:< add cachedConflict:> cachedConflict:< ]
[ add collMove:> | wantsToMoveTo:> cachedConflict:> ] sfx2
[ was wantsToMoveTo:dirs ]

(conflict at non-snake-moving tile pushed into multiple directions)
[ checkMove:> checkMove:^ no follow:dirs snakeMove:dirs add collMove:> collMove:^ ] sfx2
[ checkMove:> checkMove:< no follow:dirs snakeMove:dirs add collMove:> collMove:< ] sfx2

(stop all pushing that can't happen due to a conflict)
(in front)
[ collMove:>    | checkMove:> no snakeMove:> collMove:> add discardMove:> ]
[ discardMove:> | checkMove:> no snakeMove:> collMove:> add discardMove:> ]
+ dirs [ discardMove:dirs con:> | con:< no snakeMove:dirs add discardMove:dirs ]

(behind conflicts, spread collision. these tiles will show a collision animation.)
(checkFollow will be cancelled)
(discardFollow will be spread, which can cause additional checkMoves to fail, leading to more discardFollow)
  [ checkMove:> add collMove:> | collMove:> ]
+ dirs [ collMove:dirs con:> | con:< add collMove:dirs ]
+ dirs [ follow:> add discardFollow | snakeMove:dirs collMove:dirs ]
+ [ discardFollow con:> | con:< no snakeMove:dirs add discardFollow ] (spread, including from snake head)
+ [ snakeMove:dirs was discardFollow ] (but don't leave on snake head)
+ [ discardFollow was checkFollow:dirs ]
+ [ checkFollow:> add collMove:> | snakeMove:>   collMove:dirs add cachedConflict:> ]
+ [ checkFollow:> add collMove:> | discardFollow add cachedConflict:> ]

(cache these added collisions behind the conflicts)
[ checkMove:> collMove:> add cachedColl:> cachedConflict:> ]

(clear the movement)
[ collMove:> del push:>/snakeMove:> ]
[ discardMove:> del push:>/snakeMove:> ]
[ discardFollow del follow:dirs ]

(snake can move)
[ follow:> add snakeMove:> ]
[ snakeMove:dirs del push:dirs ]

(don't visualize multi-directional collision)
[ was collMove:> collMove:v ]
[ was collMove:> collMove:< ]

(don't add to the undo queue if the player collided)
[ player collMove:> ] -> nosave




(MOVE CAN HAPPEN)
(sound)
[ snakeMove:dirs ] -> sfx0 (sound)


(REFRESH COLLISION AND CONFLICT CACHE)

(refresh collision and conflict markers at push)
dirs [ push:>/snakeMove:> cachedColl:dirs add refresh_cache:dirs ]
dirs [ push:>/snakeMove:> cachedConflict:dirs add refresh_cache:dirs ]

(refresh collision marker behind already refreshed collision marker)
(refresh collision marker behind already refreshed conflict marker of any direction)
(refresh conflict marker in front of already refreshed collision marker)
  [ cachedColl:> add refresh_cache:> | refresh_cache:> ]
+ [ cachedColl:> add refresh_cache:> | refresh_cache:dirs cachedConflict:dirs ]
+ [ cachedColl:> refresh_cache:> | cachedConflict:> add refresh_cache:> ]
+ dirs [ con:> refresh_cache:dirs | con:< add refresh_cache:dirs ] (spread through multiblocks)

[ refresh_cache:dirs del cachedColl:dirs cachedConflict:dirs ]
[ was refresh_cache:dirs ]



(split movement into item and block movement again)
[ push:>/snakeMove:> gpItem add itemPush:> ]
[ gpItem no snake was push:> ]


(actually do the movement)
(use markers to move all items in those tiles)

(items and their flying movement)
startloop
       [ itemPush:> was gpItem       | no itemPush:dirs add gpItem ]
  dirs [ itemPush:> was now_fly:dirs | no itemPush:dirs add now_fly:dirs ]
  [ was itemPush:>  no gpItem        | no itemPush:dirs add wasItemMoved:> ]
endloop

(snake parts)
startloop
  [     push:> was gpSnake | no gpFullBlockMove add gpSnake ]
  [ was push:>  no gpSnake | no gpFullBlockMove add wasMoved:>   ] sfx3 (pushed)
  [     snakeMove:> was gpSnake | no gpFullBlockMove add gpSnake ]
  [ was snakeMove:>  no gpSnake | no gpFullBlockMove add wasSnakeMoved:> ]
endloop

(item pushed sound)
[ wasItemMoved:dirs no wasSnakeMoved:dirs ] sfx3 (pushed)

(move done:)

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs                                      is con:< add correctConnectDir:< ]
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs no correctConnectDir:< was con:dirs add con:< add correctConnectDir:< ]
(if there is another connection or cut, make it face backwards again )
dirs [ wasSnakeMoved:< no correctConnectDir:dirs was con:dirs add con:> correctConnectDir:> ]
dirs [ wasSnakeMoved:<                           was cut:dirs add cut:> correctConnectDir:> ]
[ was correctConnectDir:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ wasMoved:dirs/wasSnakeMoved:dirs cut:> | cut:< no wasMoved:dirs wasSnakeMoved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ wasMoved:dirs/wasSnakeMoved:dirs was con:> add cut:> | no con:< ] sfx1
[ was con:> add cut:> | no con:< wasMoved:dirs/wasSnakeMoved:dirs ] sfx1

(moved item starts flying if there is space)
[ gpItem wasSnakeMoved:> wasItemMoved:dirs con:>/cut:> no again_fly:dirs add again_fly:> | no gpItem ]
[ gpItem wasItemMoved:> con:>/cut:>       no again_fly:dirs add again_fly:> ]
[ gpItem wasItemMoved:> cut:< con:v/cut:v no again_fly:dirs add again_fly:v ]
[ gpItem wasItemMoved:> cut:< con:^/cut:^ no again_fly:dirs add again_fly:^ ]
[ gpItem wasItemMoved:> no snake          no again_fly:dirs add again_fly:> ]
(immediately remove if it can't actually fly, only push)
[ gpItem wasItemMoved:> was again_fly:> | snake no cut:< con:< ]
(prevent item flying into player in a closed snake)
[ gpItem wasSnakeMoved:dirs was again_fly:> | snake gpItem ]

(for snakeMoved, perpendicular is fine too, as in when an item was dragged around a corner of the snake)
[ wasSnakeMoved:perpendicular wasItemMoved:dirs con:>/cut:> gpItem no again_fly:dirs add again_fly:> | no gpItem ]

(if cut was moved into item, the item moves the other way)
[ wasMoved:> cut:> gpItem no wasItemMoved:dirs again_fly:dirs add again_fly:< ]



(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those after the moves)
[ was any:dirs ]
[ con:>/cut:> add any:> ]

(reconnect cuts)
[ was cut:> add con:> | was cut:< add con:< ]


(find which snake multiblocks are partially not over a hole)
[ was supported ]
[ snake no hole add supported ]
[ supported con:> | con:< add supported ]

(the rest fall into hole)
[ hole snake no supported add again_gravity ]
[ hole gpItem no again_fly:dirs now_fly:dirs supported add again_gravity ]

(fall into meta exit or fly back out)
[ player meta_exit any:< add again_exit | wall ]
[ player meta_exit any:< add now_fly:< | no wall ]
[ npc    meta_exit any:< add now_fly:< ] (just always leave again)


(reset player direction if not valid)
[ player snake no any:< ] [ was playerFacing:> add playerFacing:v ] 



(----FLY----)

(check what should fly this turn) 
(do something with each flying item now)

(hit snake end)
[ gpItem snake meta_exit/spawnpoint no any:> was now_fly:> ]
[ gpItem snake                      no any:> was now_fly:> add col_snake:> ] sfx7 (soft collision)

(hit wall/ block)
[ gpItem was now_fly:> add col_item:> maybeBounce | wall ] sfx0 (movement click)
[ gpItem was now_fly:> add col_item:> maybeBounce | snake no any:< add collMove:> ] sfx0

(hit other flying item/ stationary item)
[ gpItem was now_fly:> add again_fly:<            | gpItem was now_fly:<   add again_fly:> ] sfx0 (what about a perpendicular one? WIP)
[ gpItem was now_fly:> add col_item:> maybeBounce | gpItem is now_fly:dirs                 ] sfx0
[ gpItem was now_fly:> add col_item:> maybeBounce | gpItem no now_fly:dirs add again_fly:> ] sfx0

(identify tiles multiple items want to fly to)
[ was wantsToFlyTo:dirs ] (clean the markers from last time)
[ gpItem now_fly:> | add wantsToFlyTo:> ]
[ was wantsToFlyTo:> was wantsToFlyTo:</wantsToFlyTo:perpendicular ]
(bounce those items back instead)
[ gpItem was now_fly:> add again_fly:< | no wantsToFlyTo:> ]

(instead of colliding in place, player item will always bounce back)
[ player was col_item:> maybeBounce add again_fly:< ]
[ was maybeBounce ]

(default flying:)
(move to empty space)
[ was gpItem now_fly:> | no gpItem now_fly:dirs add gpItem again_fly:> ]


(----FLYING DONE----)

(player faces direction of flying)
[ player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(spread collisions ... note, this doesn't also show up on multipushed blocks)
dirs [ collMove:dirs con:> | add collMove:dirs ]

(----QUEUE PUSHES FROM MOVERS----)

(find multiblocks that could move due to npc)
(if there was already an attempt that collided, the collision is cached.)
(it is updated if a relevant part of the collided blocks was moved.)
[ snake any:< npc no again_fly:< any:v any:^ any:> cachedColl:> cachedConflict:> add again_move:>  ]



(----VISUAL ONLY----)

[ was tempVisualObjects ]

(show snake)
[ snake add vs_snake_base ]

(outline towards other connected snake part)
[ con:> add vs_con_lowest:> ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ cut:> | was stationary.wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(clean edge on sides without cut/con)
[ snake no any:> add vs_snake_edge:> ]

(add dot on rail ending in the center because it only goes to one neighbor)
[ snake no any:v any:^ any:> add vs_con_end ]

(npc at snake end)
[ npc snake any:< no any:v any:^ any:> again_fly:< add vs_npc:> ]
[ npc no vs_npc:dirs add vs_npc_off ]

(direction for eye)
[ playerFacing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( spawn point - show as filled when entering the level and hide the player )
[ spawnpoint any:> add vs_meta_pipe:< ]
[ again_spawn was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit - show as filled when exiting and hide the player)
[ meta_exit any:> add vs_meta_pipe:< ]
[ again_exit was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit arrow)
[ meta_exit any:< | wall add vs_meta_arrow:> ]


(----ACTIVATE COLLISION VARIANTS----)

(always animate items on a colliding block cell)
[ gpItem collMove:>/col_snake:> add col_item:> ]

(animate tiles in collision by replacing them with offset variants)
[ col_item:> was ball       add ball:> ] 
[ col_item:> was vs_npc_off add vs_npc_off:> ]

dirs [ col_item:> was vs_player:dirs add vs_player:dirs:> ]
dirs [ col_item:> was vs_npc:dirs    add vs_npc:dirs:> ]

[ collMove:> was vs_snake_base add vs_snake_base:> ] 
[ collMove:> was vs_con_end    add vs_con_end:> ] 

dirs [ collMove:> was vs_con_lowest:dirs       add vs_con_lowest:dirs:> ]
dirs [ collMove:> was con:dirs                 add con:dirs:> ]
dirs [ collMove:> was cut:dirs                 add cut:dirs:> ]
dirs [ collMove:> was vs_snake_edge:dirs       add vs_snake_edge:dirs:> ]
dirs [ collMove:> was vs_meta_pipe:dirs        add vs_meta_pipe:dirs:> ]
dirs [ collMove:> was vs_meta_pipe_closed:dirs add vs_meta_pipe_closed:dirs:> ]

(extend forwards)
[ col_snake:> is vs_con_end add vs_snake_col:> ] 


(----START AGAIN TURNS----)

(fall into hole/exit after shown over it)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_spawn ] -> sfx8 again (appear sound)

(fly again)
[ again_fly:> gpItem ] -> again

(move multiblock after there was space for it)
[ again_move:> ] -> again

(to go back from the collision animation to default state)
[ was collMove:dirs/col_item:dirs/col_snake:dirs add again_col ] again

(% endfilter %)