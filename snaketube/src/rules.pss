(% filter relaxRules %)

(----AGAIN TURN----)
(these are in a previously started again turn)

(stuff on snake falls into hole)
(ball and player fall into hole if not flying)
[ hole again_gravity was it_canFall ]
[ hole again_gravity no again_fly:dirs was ball/player ]
(replace snake and hole itself with floor)
[ was hole again_gravity snake add floor ]


(items appear from spawn)
[ con:>/cut:> was again_spawn add again_fly:> playerFacing:> ]
(no place to go? ... WIP, should later send it back)
[ was again_spawn add playerFacing:right ]

(items fall into meta exit, winning the level)
[ was it_canFly was again_exit ] win


(revert collision)
(swap the shifted collision anim objects out with the regular ones)
(other objects get regenerated every turn anyway & don't need to be swapped back here)
[ again_col ] [ was ball:offs add ball ]
dirs [ again_col ] [ was con:dirs:offs          add con:dirs ]
dirs [ again_col ] [ was cut:dirs:offs          add cut:dirs ]
dirs [ again_col ] [ was brokenplayer:dirs:offs add brokenplayer:dirs ]
dirs [ again_col ] [ was brokenball:dirs:offs   add brokenball:dirs ]
[ was again_col ]



(----INIT----)
(do these at the start of the turn, then remove the init marker.)

(connect any snakes in level)
[ init ] [ snake no init_conBnotA/init_conAnotB init_noMoreCon cut:> add con:> | snake no init_conBnotA/init_conAnotB init_noMoreCon cut:< add con:< ]
[ init ] [ player was con:> | was con:< init_connectRules ]

(spawnpoints/meta_exit)
[ init ] [ spawnpoint/meta_exit no con:dirs cut:dirs add cut:> | no wall ]

(connect walls)
[ init ] [ wall add vs_any_under:> vs_wall_con:> ]
[ init ] [ wall was vs_any_under:> vs_wall_con:> | no wall ]

(wall edge)
[ init ] [ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]

[ init ] [ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(wall edge decoration)
[ init ] [ vs_wall_inner:v | vs_wall_inner:v | vs_wall_inner:v no vs_wall_inner:^ add vs_wall_inner_deco:v | vs_wall_inner_corner:> ]
[ init ] [ vs_wall_inner_corner:^ | vs_wall_inner:v no vs_wall_inner:^ add vs_wall_inner_deco:v | vs_wall_inner:v | vs_wall_inner:v ]

(outside decoration)
[ init ] [ vs_outside add init_notOutside:> | no vs_outside no vs_outside_pattern:dirs ] (which other tiles do these corners face?)
[ init ] [ init_notOutside:> init_notOutside:^ add vs_outside_pattern:> ]
[ init ] [ init_notOutside:> was vs_outside add vs_outside_pattern:> ]
[ init ] [ vs_outside_pattern:^ | was vs_outside_pattern:^ add vs_outside_pattern:> ]
[ init ] [ was vs_outside_pattern:> add vs_outside_pattern:^ | vs_outside_pattern:> ]
(hole border)
[ init ] [ no hole add floor ]
[ init ] [ hole add vs_hole_edge:> | floor ]

(add checker to initial floor)
[ init ] [ player | add checker ]
[ init ] [ checker | | add checker ]
[ init ] [ no floor was checker ]

(from a spawnpoint, the player appears)
[ init ] [ spawnpoint player add again_spawn ]

(remove markers only used for init)
[ init ] [ was init_conAnotB/init_conBnotA/init_noMoreCon ]

(remove init) 
[ was init ]



(----SET AT START OF ROUND ---)

(any markers, these are used to sometimes ignore which kind of connections are actually present)
(but record the directions of connection for later in the turn)
[ was any:dirs ]
[ con:>/cut:> add any:> ]



(----PLAYER INPUT---)

(always face the right way when starting a move)
[ >.player ] [ was playerFacing:dirs add playerFacing:> ]

(move out of connector starts flight)
[ any:> was >.player add stationary.player again_fly:> ]

(move in any other direction, trying to pilot the object)
[ wall was >.player add stationary.player col_effect:> ] nosave

(works for snake)
[ was >.player add stationary.player turnMove:> ]



(----FLY----)

(reorient sliding direction based on pipe around)
(the stationary makes sure they can only do this once)
(if anything else, like pushing leads to flying, on the initial turn this isn't done...)
[ any:v no wasMoved:> was stationary.again_fly:> add v.again_fly:v ]
[ any:^ no wasMoved:> was stationary.again_fly:> add ^.again_fly:^ ]

(reset temporary marker)
[ was again_fly:dirs add stationary.again_fly:dirs ]


(check what should happen this turn) 
(if there's a match, skip all remaining cases using a temporary action marker)

(if flying into snake end, stop and collide)
[ it_canFly snake no any:> was stationary.again_fly:> add col_effect:> ]

(if flying into wall, remove and leave broken effect)
[ was stationary.again_fly:> player/ball | wall add brokenplayer:</brokenball:< ] sfx6 (breaking sound)

(if flying into snake, try to push the snake)
[ was stationary.again_fly:> player/ball | snake no any:< add brokenplayer:</brokenball:< move:> ] sfx6 (breaking sound)

(if flying into another flying object, both repel)
[ it_canFly was stationary.again_fly:> add action.again_fly:< | it_canFly was stationary.again_fly:< add action.again_fly:> ] sfx7

(if flying into stationary object at snake end, repel and steer)
[ it_canFly was stationary.again_fly:> add action.again_fly:< | snake it_canFly no any:> any:perpendicular add turnMove:> ] sfx7

(if flying into stationary object that could move, both repel)
[ it_canFly was stationary.again_fly:> add action.again_fly:< | it_canFly add action.again_fly:> ] sfx7

(if flying into empty space that another object wants to fly into)
(first place directional markers in the empty space)
[ it_canFly stationary.again_fly:> | add wantsToFlyTo:> ]
(remove the markers if there is overlap)
[ was wantsToFlyTo:> was wantsToFlyTo:</wantsToFlyTo:perpendicular ]
(now check for moving into empty space with the marker missing)
[ it_canFly was stationary.again_fly:> add action.again_fly:> | no wantsToFlyTo:> ]
(clear the markers)
[ was wantsToFlyTo:dirs ]

(if flying into any other tile, just move one tile)
[ was it_canFly stationary.again_fly:> | add it_canFly action.again_fly:> ]



(----FLYING DONE----)

(reset temporary markers)
[ was again_fly:dirs add stationary.again_fly:dirs ]

(if flying, set player facing)
[ player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(spread collisions)
[ col_effect:dirs con:> | add col_effect:dirs ]



(----MOVE OBJECTS----)

( 
- starts from a turnMove, i.e. a snakelike move that makes a tile orient itself
- marks all pushing and turning tiles at once, checking if anything collides
- push markers overwrite snake movement, so you can build a contraption to push yourself without turning
- the head pushing into the snake body makes the body split off, because push markers have priority
)

(remove temp from last time)
[ was wasMoved:dirs/wasTurnMoved:dirs/follow:dirs ]

(propagate forward from a pusher)
[ turnMove:> | snake add move:> ]

(loop to propagate regular move forward and also through connections whenever possible.)
(in forward direction-so with actual pressure, it can even affect the snake head doing the push, such as in a C shape)
(otherwise, through a connection only spread if there is no turnMove:dirs there)
[ move:> | snake add move:> ]
+ [ move:dirs con:> | con:< no turnMove:dirs add move:dirs ]

(however, IF the shape itself is pushed and it now has both turnMove and move, currently it then spreads to the whole tail.)
(so for now, in that case there should be no snake movement at all and the whole thing just translates.)
[ move:dirs del turnMove:dirs ]

(so far there are tiles being moved and possibly a head tile with a turnMove.)
(check collision now, show animation and cancel any actual movement if so)
[ was move:>/turnMove:> add col_effect:> | it_collides no move:> ] nosave
(collision animation, remove all markers)
dirs [ col_effect:> ] [ was move:dirs/turnMove:dirs add col_effect:dirs ]
(also spread through tiles that weren't moved if they are connected)
dirs [ col_effect:dirs con:> | con:< no col_effect:dirs add col_effect:dirs ]

(add marker to indicate in what direction and where the snake should be followed)
[ con:> no move:dirs add follow:> | con:< turnMove:dirs ]

(do the movement)
(use markers to move all items in those tiles)
  [     move:> was it_movesOnSnake | no any_move add it_movesOnSnake ]
+ [            was move:>          | no any_move add wasMoved:>      ] sfx3
+ [ turnMove:> was it_movesOnSnake | no any_move add it_movesOnSnake ]
+ [            was turnMove:>      | no any_move add wasTurnMoved:>  ]

(add turnMove markers behind the first one, starting from the follow:>)
(exclude anything that already moved)
[      no snake | con:< no wasMoved:dirs wasTurnMoved:dirs  was follow:< add turnMove:< ]
[ turnMove:dirs | con:< no wasMoved:dirs wasTurnMoved:dirs turnMove:dirs add turnMove:< ]

(move the tail following the tile )
(this assumes there is always one tile that can move, and moves them in order )
startloop
    [ turnMove:> was it_movesOnSnake | no any_move add it_movesOnSnake ]
    random [ was turnMove:> | no any_move add wasTurnMoved:> ]
endloop

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ wasTurnMoved:< | wasTurnMoved:dirs                                      is con:< add correctConnectDir:< ]
dirs [ wasTurnMoved:< | wasTurnMoved:dirs no correctConnectDir:< was con:dirs add con:< add correctConnectDir:< ]
(if there is another connection or cut, make it face backwards again )
dirs [ wasTurnMoved:< no correctConnectDir:dirs was con:dirs add con:> correctConnectDir:> ]
dirs [ wasTurnMoved:<                           was cut:dirs add cut:> correctConnectDir:> ]
[ was correctConnectDir:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ wasMoved:dirs/wasTurnMoved:dirs cut:> | cut:< no wasMoved:dirs no wasTurnMoved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ wasMoved:dirs/wasTurnMoved:dirs was con:> add cut:> | no con:< ] sfx1

(a moved flying item will start flying if there is an open end that direction)
[     wasMoved:> con:>/cut:> it_canFly no again_fly:dirs add again_fly:> ]
[ wasTurnMoved:> con:>/cut:> it_canFly no again_fly:dirs add again_fly:> | no it_canFly ]

(for turnMoved, perpendicular is fine too, as in when a ball was dragged around a corner of the snake)
[ wasTurnMoved:perpendicular con:>/cut:> it_canFly no again_fly:dirs add again_fly:> | no it_canFly ]

(remove effect of broken player/ball if snake was turnmoved)
[ wasTurnMoved:> was brokenplayer:dirs/brokenball:dirs ]



(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those for the next turn)
[ was any:dirs ]
[ con:>/cut:> add any:> ]

(reconnect cuts)
[ was cut:> add con:> | was cut:< add con:< ]

(find which snake multiblocks are partially not over a hole)
[ was supported ]
[ snake no hole add supported ]
[ supported con:> | con:< add supported ]

(the rest fall into hole)
[ snake no supported add again_gravity ]

(items fall into meta exit)
[ it_canFly meta_exit add again_exit ]



(----VISUAL ONLY----)

[ was tempVisualObjects ]

(update edge of hole)
[ floor add vs_hole_edge:> | hole ] (not actually a temp object, but sometimes needs to get added)

(default/ active snake detail)
[ snake ./player add vs_snake_under/vs_active_under ]
[ vs_active_under con:> | add vs_active_under ]

(connections/ cuts)
[ any:> snake/vs_active_under add vs_any_under:> vs_con:>/vs_con_active:> ]
[ cut:> add vs_snake_opening:> ]
[ snake no con:> cut:> add vs_snake_edge:> ]

(direction for eye)
[ playerFacing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( spawn point - show as filled when entering the level and hide the player )
[ spawnpoint con:>/cut:> add vs_meta_pipe:< ]
[ again_spawn was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit - show as filled when exiting and hide the player)
[ meta_exit  con:>/cut:> add vs_meta_pipe:< ]
[ again_exit was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

(animate tiles in collision by replacing them with offset variants)
[ col_effect:> was ball            add ball:> ] 
[ col_effect:> was vs_snake_under  add vs_snake_under:> ] 
[ col_effect:> was vs_active_under add vs_active_under:> ] 
dirs [ col_effect:> was con:dirs                 add con:dirs:> ]
dirs [ col_effect:> was cut:dirs                 add cut:dirs:> ]
dirs [ col_effect:> was brokenplayer:dirs        add brokenplayer:dirs:> ]
dirs [ col_effect:> was brokenball:dirs          add brokenball:dirs:> ]
dirs [ col_effect:> was vs_any_under:dirs        add vs_any_under:dirs:> ]
dirs [ col_effect:> was vs_con:dirs              add vs_con:dirs:> ]
dirs [ col_effect:> was vs_con_active:dirs       add vs_con_active:dirs:> ]
dirs [ col_effect:> was vs_player:dirs           add vs_player:dirs:> ]
dirs [ col_effect:> was vs_snake_edge:dirs       add vs_snake_edge:dirs:> ]
dirs [ col_effect:> was vs_snake_opening:dirs    add vs_snake_opening:dirs:> ]
dirs [ col_effect:> was vs_meta_pipe:dirs        add vs_meta_pipe:dirs:> ]
dirs [ col_effect:> was vs_meta_pipe_closed:dirs add vs_meta_pipe_closed:dirs:> ]



(----START AGAIN TURNS----)

(fall into hole/exit after shown over it)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_spawn ] -> sfx8 again (appear sound)

(fly again)
[ again_fly:> it_canFly ] -> again

(to go back from the collision animation to default state)
[ was col_effect:dirs add again_col ] sfx2 again

(% endfilter %)