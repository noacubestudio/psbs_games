(% filter relaxRules %)
(----INIT----)
(do these at the start of the turn, then remove the init marker.)

(connect any snakes in level)
[ init ] [ snake no init_conBnotA/init_conAnotB init_noMoreCon cut:> add con:> | snake no init_conBnotA/init_conAnotB init_noMoreCon cut:< add con:< ]
[ init ] [ player was con:> | was con:< init_connectRules ]

(connect tracks, tracks = solid pipes in walls)
[ init ] [ track add vs_track_bg ]
[ init ] [ track add trc:> vs_trc_under:> | track ]
[ init ] [ track add trc:> vs_trc_under:> no init_noMoreCon | no wall ]
[ init ] [ trc:> no trc:v trc:^ add trc:< vs_trc_under:< ]

(wall edge)
[ init ] [ wall no trc:> add vs_wall_inner:> vs_wall_edge:> | no wall ]
[ init ] [      is trc:> add vs_wall_inner:>                | no wall ] (vs_wall_opening:> is added dynamically later)
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> ]

(hole border)
[ init ] [ no hole add floor ]
[ init ] [ hole add vs_hole_edge:> | floor ]

(starting direction eye is facing)
[ init player con:> no con:< add playerFacing:> ]
[ init player trc:>          add playerFacing:> | trc:< ]

(also set move direction to start with here)
[ init add playerFacing:> ] [ player trc:> add again_fly:> | trc:< ]

(end init) 
(start of first player turn or again turn ends init)
[ > player    ] [ was init add playerFacing:> ] 
[ again_fly:> ] [ was init ]

(------------------)

(on every player turn after, also reorient the playerFacing marker)
[ > player ] [ was playerFacing:dirs add playerFacing:> ]

(init stuff I can't remove earlier, not sure why)
[ > player ] [ was init_conAnotB/init_conBnotA/init_noMoreCon ]

(----AGAIN TURN----)
(these are in a previously started again turn)

(stuff on snake falls into hole)
(ball and player fall into hole if not flying)
[ hole again_gravity was it_canFall ]
[ hole again_gravity no again_fly:dirs was ball/player ]
(replace snake and hole itself with floor)
[ was hole again_gravity snake add floor ]

(update edge of hole)
[ floor add vs_hole_edge:> | hole ]

(revert collision)
(swap the shifted collision anim objects out with the regular ones)
(other objects get regenerated every turn anyway & don't need to be swapped back here)
[ again_col ] [ was ball:offs add ball ]
dirs [ again_col ] [ was con:dirs:offs          add con:dirs ]
dirs [ again_col ] [ was cut:dirs:offs          add cut:dirs ]
dirs [ again_col ] [ was brokenplayer:dirs:offs add brokenplayer:dirs ]
dirs [ again_col ] [ was brokenball:dirs:offs   add brokenball:dirs ]
[ was again_col ]



(----SET AT START OF ROUND ---)

(any markers, these are used to sometimes ignore which kind of connections are actually present)
(but record the directions of connection for later in the turn)
[ was any:dirs ]
[ con:>/cut:>/trc:> add any:> ]


(----PLAYER INPUT---)

(move out of connector starts slide)
[ any:> was >.player add stationary.player again_fly:> ]

(move in any other direction, trying to pilot the object)
[ wall was >.player add stationary.player anim_col:> ] nosave

(works for snake)
[ was >.player add stationary.player turnMove:> ]


(----FLY----)

(reorient sliding direction based on pipe around)
(the stationary makes sure they can only do this once)
(if anything else, like pushing leads to flying, on the initial turn this isn't done...)
[ any:v no wasMoved:> was stationary.again_fly:> add v.again_fly:v ]
[ any:^ no wasMoved:> was stationary.again_fly:> add ^.again_fly:^ ]

(reset temporary marker)
[ was again_fly:dirs add stationary.again_fly:dirs ]


(check what should happen this turn) 
(if there's a match, skip all remaining cases using a temporary action marker)

(if flying into snake end, stop and collide)
[ it_canFly snake no any:> was stationary.again_fly:> add anim_col:> ]
[ fixed was anim_col:dirs ] sfx2

(if flying into level border, remove)
[ trc:> was stationary.again_fly:> player/ball | wall no trc:< win/. ]

(if flying into wall, remove and leave broken effect)
[ was stationary.again_fly:> player/ball | wall no win any:< add brokenplayer:</brokenball:< ] sfx6 (breaking sound)

(if flying into snake, try to push the snake)
[ was stationary.again_fly:> player/ball | snake no any:< add brokenplayer:</brokenball:< move:> ] sfx6 (breaking sound)

(if flying into another flying object, both repel)
[ it_canFly was stationary.again_fly:> add action.again_fly:< | it_canFly was stationary.again_fly:< add action.again_fly:> ] sfx7

(if flying into stationary object at snake end, repel and steer)
[ it_canFly was stationary.again_fly:> add action.again_fly:< | snake it_canFly no any:> any:perpendicular add turnMove:> ] sfx7

(if flying into stationary object that could move, both repel)
[ it_canFly was stationary.again_fly:> add action.again_fly:< | it_canFly add action.again_fly:> ] sfx7

(if flying into empty space that another object wants to fly into)
(first place directional markers in the empty space)
[ it_canFly stationary.again_fly:> | add wantsToFlyTo:> ]
(remove the markers if there is overlap)
[ was wantsToFlyTo:> was wantsToFlyTo:</wantsToFlyTo:perpendicular ]
(now check for moving into empty space with the marker missing)
[ it_canFly was stationary.again_fly:> add action.again_fly:> | no wantsToFlyTo:> ]
(clear the markers)
[ was wantsToFlyTo:dirs ]

(if flying into any other tile, just move one tile)
[ was it_canFly stationary.again_fly:> | add it_canFly action.again_fly:> ]


(----FLYING DONE----)

(reset temporary markers)
[ was again_fly:dirs add stationary.again_fly:dirs ]

(if flying, set player facing)
[ player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(spread collisions)
[ anim_col:dirs con:> | add anim_col:dirs ]


(----MOVE OBJECTS----)

( 
- starts from a turnMove, i.e. a snakelike move that makes a tile orient itself
- marks all pushing and turning tiles at once, checking if anything collides
- push markers overwrite snake movement, so you can build a contraption to push yourself without turning
- the head pushing into the snake body makes the body split off, because push markers have priority
)

(remove temp from last time)
[ was wasMoved:dirs/wasTurnMoved:dirs/follow:dirs ]

(propagate forward from a pusher)
[ turnMove:> | snake no fixed add move:> ]

(loop to propagate regular move forward and also through connections whenever possible.)
(in forward direction-so with actual pressure, it can even affect the snake head doing the push, such as in a C shape)
(otherwise, through a connection only spread if there is no turnMove:dirs there)
[ move:> | snake add move:> ]
+ [ move:dirs con:> | con:< no turnMove:dirs add move:dirs ]

(however, IF the shape itself is pushed and it now has both turnMove and move, currently it then spreads to the whole tail.)
(so for now, in that case there should be no snake movement at all and the whole thing just translates.)
[ move:dirs del turnMove:dirs ]

(so far there are tiles being moved and possibly a head tile with a turnMove.)
(check collision now, show animation and cancel any actual movement if so)
[ was move:>/turnMove:> add anim_col:> | it_collides no move:> ] nosave
(collision animation, remove all markers)
dirs [ anim_col:> ] [ was move:dirs/turnMove:dirs add anim_col:dirs ]
(also spread through tiles that weren't moved if they are connected)
dirs [ anim_col:dirs con:> | con:< no anim_col:dirs add anim_col:dirs ]

(add marker to indicate in what direction and where the snake should be followed)
[ con:> no move:dirs add follow:> | con:< turnMove:dirs ]

(do the movement)
(use markers to move all items in those tiles)
  [     move:> was it_movesOnSnake | no any_move add it_movesOnSnake ]
+ [            was move:>          | no any_move add wasMoved:>      ] sfx3
+ [ turnMove:> was it_movesOnSnake | no any_move add it_movesOnSnake ]
+ [            was turnMove:>      | no any_move add wasTurnMoved:>  ]

(add turnMove markers behind the first one, starting from the follow:>)
(exclude anything that already moved)
[      no snake | con:< no wasMoved:dirs wasTurnMoved:dirs fixed  was follow:< add turnMove:< ]
[ turnMove:dirs | con:< no wasMoved:dirs wasTurnMoved:dirs fixed turnMove:dirs add turnMove:< ]

(move the tail following the tile )
(this assumes there is always one tile that can move, and moves them in order )
startloop
    [ turnMove:> was it_movesOnSnake | no any_move add it_movesOnSnake ]
    random [ was turnMove:> | no any_move add wasTurnMoved:> ]
endloop

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ wasTurnMoved:< | wasTurnMoved:dirs                                      is con:< add correctConnectDir:< ]
dirs [ wasTurnMoved:< | wasTurnMoved:dirs no correctConnectDir:< was con:dirs add con:< add correctConnectDir:< ]
(if there is another connection or cut, make it face backwards again )
dirs [ wasTurnMoved:< no correctConnectDir:dirs was con:dirs add con:> correctConnectDir:> ]
dirs [ wasTurnMoved:<                           was cut:dirs add cut:> correctConnectDir:> ]
[ was correctConnectDir:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ wasMoved:dirs/wasTurnMoved:dirs cut:> | cut:< no wasMoved:dirs no wasTurnMoved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ wasMoved:dirs/wasTurnMoved:dirs/fixed was con:> add cut:> | no con:< ] sfx1

(a moved flying item will start flying if there is an open end that direction)
[     wasMoved:> con:>/cut:> it_canFly no again_fly:dirs add again_fly:> ]
[ wasTurnMoved:> con:>/cut:> it_canFly no again_fly:dirs add again_fly:> | no it_canFly ]

(for turnMoved, perpendicular is fine too, as in when a ball was dragged around a corner of the snake)
[ wasTurnMoved:perpendicular con:>/cut:> it_canFly no again_fly:dirs add again_fly:> | no it_canFly ]

(remove effect of broken player/ball if snake was turnmoved)
[ wasTurnMoved:> was brokenplayer:dirs/brokenball:dirs ]

(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those for the next turn)
[ was any:dirs ]
[ con:>/cut:>/trc:> add any:> ]

(reconnect cuts)
[ was cut:> add con:> | was cut:< add con:< ]

(find which snake multiblocks are partially not over a hole)
[ was supported ]
[ snake no hole add supported ]
[ supported con:> | con:< add supported ]

(the rest fall into hole)
[ snake no supported add again_gravity ]

(find which blocks are totally fixed and will not even show collision bounce)
[ was fixed ]
[ wall add fixed ]
[ fixed trc:>/con:> | cut:</con:< add fixed ]


(----VISUAL ONLY----)

[ was tempVisualObjects ]

(layer more detail on snakes)

(default/ active)
[ snake ./player add vs_snake_under/vs_active_under ]

(spread)
[ vs_active_under con:> | add vs_active_under ]

(connect/cut)
[ any:> snake/vs_active_under add vs_any_under:> vs_con:>/vs_con_active:> ]
[ cut:> add vs_snake_opening:> ]
[ snake no con:> cut:> add vs_snake_edge:> ]

(temporarily hide wall opening and snake opening to make them look connected)
[ trc:> add vs_wall_opening:> | no wall ]
[ was vs_wall_opening:> add vs_con:> | was vs_snake_opening:< ]


(direction for eye)
[ playerFacing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

(animate tiles in collision by replacing them with offset variants)
[ anim_col:> was ball            add ball:> ] 
[ anim_col:> was vs_snake_under  add vs_snake_under:> ] 
[ anim_col:> was vs_active_under add vs_active_under:> ] 
dirs [ anim_col:> was con:dirs              add con:dirs:> ]
dirs [ anim_col:> was cut:dirs              add cut:dirs:> ]
dirs [ anim_col:> was brokenplayer:dirs     add brokenplayer:dirs:> ]
dirs [ anim_col:> was brokenball:dirs       add brokenball:dirs:> ]
dirs [ anim_col:> was vs_any_under:dirs     add vs_any_under:dirs:> ]
dirs [ anim_col:> was vs_con:dirs           add vs_con:dirs:> ]
dirs [ anim_col:> was vs_con_active:dirs    add vs_con_active:dirs:> ]
dirs [ anim_col:> was vs_player:dirs        add vs_player:dirs:> ]
dirs [ anim_col:> was vs_snake_edge:dirs    add vs_snake_edge:dirs:> ]
dirs [ anim_col:> was vs_snake_opening:dirs add vs_snake_opening:dirs:> ]

(----START AGAIN TURNS----)

(fall into hole after shown over it)
[ again_gravity ] -> sfx4 again

(fly again)
[ again_fly:> it_canFly ] -> again

(to go back from the collision animation to default state)
[ was anim_col:dirs add again_col ] sfx2 again

(% endfilter %)