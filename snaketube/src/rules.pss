(% filter relaxRules %)

(----SUBROUTINES----)

(gosub handle_queued_from_last_turn: turn continued from last turn without input)
(gosub initialize_level: once at init then never again)
(gosub redraw_visuals: always)
(gosub queue_again: start turn to continue anim/ flying etc)

[ gp_again        ] -> gosub handle_queued_from_last_turn
[ init            ] -> gosub initialize_level 
[ moving player   ] -> gosub handle_player_input
[ gp_move_sources ] -> gosub handle_block_movement
[ player          ] -> gosub handle_player_movement
[ background      ] -> gosub redraw_visuals
[ gp_again        ] -> gosub queue_again


(=====================================================================================)
subroutine handle_queued_from_last_turn
(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(after collision animation, swap some tiles back)
(all other animated tiles are reset every turn anyway)
dirs x [ again_col ] [ was con:x:dirs:offs add con:x:dirs ]
[ was again_col ]

(gravity)
[ hole again_gravity del block con:x:dirs pusher ] (always remove these)
[ hole again_gravity no again_fly:dirs was gp_items ] (items get removed if not flying)
[ was again_gravity ]

(queued flying)
[ con:x:v no con:x:> was again_fly:> add now_fly:v ] (reorient in a pipe corner)
[ con:x:^ no con:x:> was again_fly:> add now_fly:^ ] (reorient in a pipe corner)
dirs [ was again_fly:dirs add now_fly:dirs ]

(appearing from spawn)
(respawn after trying to go back)
[ con:x:> was again_entry add again_fly:> player_facing:> player ]
(win level when exiting through meta exit)
[ room_exit  was player again_exit ] win
(if going back to spawn, player disappears and comes back later)
[ room_entry was player again_exit add again_entry ]



(=====================================================================================)
subroutine initialize_level
(----INIT----)
(do these at the start of the first turn, then never again)

(set correct color palette)
[ init_theme_1 ] -> color_palette ega white #fff lightgray #ED963F darkgray #814621 black #15121c (connect)
[ init_theme_2 ] -> color_palette ega white #fff lightgray #F0527F darkgray #962260 black #15121c (turn)
[ init_theme_3 ] -> color_palette ega white #fff lightgray #95CE3A darkgray #356B27 black #15121c (snake)
[ init_theme_4 ] -> color_palette ega white #fff lightgray #BA79DA darkgray #513879 black #15121c (c)
[ init_theme_5 ] -> color_palette ega white #fff lightgray #888EE6 darkgray #384689 black #15121c (self split)
[ init_theme_6 ] -> color_palette ega white #fff lightgray #AAB599 darkgray #41524C black #15121c (complete)

(connect blocks)
[ was con:0:> add con:1:> | was con:0:< add con:1:< ]

(connect walls)
[ wall add vs_wall_con:> ]
[ wall was vs_wall_con:> | no wall ]

(wall edge)
[ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]
[ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(arrows to previous and next rooms)
[ room_entry con:x:< | wall add vs_room_arrow:< ]
[ room_exit  con:x:< | wall add vs_room_arrow:> ]

(decoration)
[ wall_deco_s was vs_wall_inner:> add vs_wall_deco_s:> ]
[ wall_deco_m was vs_wall_inner:> add vs_wall_deco_m:> ]

(hole border)
[ hole add vs_hole_edge_1:> vs_hole_edge_2:> | no hole ]
[ hole no vs_hole_edge_2:^ | was vs_hole_edge_1:^ ]
[ was vs_hole_edge_2:^ | hole no vs_hole_edge_1:^ ]
[ was vs_hole_edge_2:< vs_hole_edge_1:^ add vs_hole_outer_corner:^ ]
[ hole no vs_hole_edge_1:> vs_hole_outer_corner:> | no hole add vs_hole_inner_corner:^ ]

(from a spawnpoint, the player appears)
[ room_entry was player add stationary.player again_entry ] (still works without run_rules_on_level_start for testing)

(remove init) 
[ was init ]



(=====================================================================================)
subroutine handle_player_input
(----PLAYER INPUT----)

(title screen, place level exit on input to trigger win and sound)
[ was moving/action player add stationary.player room_exit ] [ title_screen ]

(action to open/close manual)
[ was action.player add stationary.player ] [ screen_border no manual add manual ] [ gp_allow_manual ]
[ was action.player add stationary.player ] [ screen_border was manual ]
[ >.player ] [ screen_border was manual ] (any move should close manual)

(before the input is processed, get the direction to make the player face that way)
[ >.player ] [ was player_facing:dirs add player_facing:> ]

(player input is received while not flying, so the player is in a block.)
(move to open side starts flight, this same turn)
[ con:x:> was >.player add stationary.player now_fly:> ]

(moving into another side starts snake movement)
[ was >.player add stationary.player player_move:> ]



(=====================================================================================)
subroutine handle_block_movement
(----MOVE OBJECTS----)

(a block with a player_move moves as the head of a snake )
(multiblocks in front get pushed )
(tail follows, also using player_move. if the tail got pushed by the snake itself, then it is treated as a connected block (split from head))
(collisions or conflicts (multiple attempts to move into same tile) will prevent movement from happening, collision animation will show the problem)
(when the movement planning is done, actual movement rules transfers everything in those tiles over, tile by tile)

(SPREAD PUSH AND PUSHER MOVEMENT THROUGH BLOCKS)

(initial push)
[ player_move:> | block add push:> ]

(pushes and pusher movement gets spread to more blocks)
dirs [ push:dirs con:1:> no player vs_pusher:dirs pusher_move:dirs | con:1:< no player add push:dirs ] (through multiblocks)
+ [ push:> no vs_pusher:> pusher_move:> | block add push:> ] (block to block)
+ [ push:> pusher con:x:> add pusher_move:> ] (activate pusher)
+ [ pusher_move:> con:1:> | con:x:^ no pusher_move:dirs add pusher_move:^ ] (spread to tail)
+ [ pusher_move:> con:1:> | con:x:v no pusher_move:dirs add pusher_move:v ]
+ [ pusher_move:> con:1:> |         no pusher_move:dirs add pusher_move:> ] (default: straight line)
+ [ pusher_move:> | block no con:x:< add push:> ] (pusher tail can itself push)

(cleanup: active pusher overwrites push)
[ con:1:> pusher_move:> del push:dirs ]


(COLLISION)
[ push:>/player_move:>/pusher_move:> add try_move:> ]

(with wall)
[ try_move:> add col_move:> | wall ] sfx2 (collision sound)

(spread collision)
(backpropagate collision markers, these will animate with bounce)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ con:1:> try_move:dirs add col_move:dirs | con:1:< col_move:dirs ] (solid multiblocks all get the spread)
+ [ con:1:> try_move:> add col_move:> | con:1:< col_move:dirs ] (face towards pushing end of pusher)

(forward propagate stopping movement on the blocks that weren't going to be pushed anyway)
(these won't show bump anim)
[ col_move:>     | try_move:> no col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< add discard_move:dirs ]

(remember collisions and no longer check these for conflicts, as they already won't move)
[ col_move:>     del try_move:> push:> player_move:> pusher_move:> ]
[ discard_move:> del try_move:> push:> player_move:> pusher_move:> ]
[ was discard_move:dirs ]


(CONFLICTS)

(only movements that didn't collide into wall are left)
(now handle:)
(simultanious movement into the same spot)
(objects pushed into multiple directions at once)
(removing follow markers on pushed blocks since they separate from the snake head)

(add follow markers inside moving snakes that point to the tile nearer to the front)
[ con:1:> gp_move_sources | gp_move_sources ] -> log connected adjacent snake movers!
[ con:1:> no follow:dirs gp_move_sources add follow:> | con:1:< gp_move_sources/follow:dirs ]

(convert pushers to same format now) (WIP?)
[ con:1:> was pusher_move:> add follow:> ] 
[         was pusher_move:> add player_move:> ]

(potential conflict: object pushing into a single-tile moving block)
(if the moving block can actually move and doesn't have its own conflict, then the object will have room to move into it.)
(the try_follow:> markers are placed for now so this will be checked later)
(no pushing through the block head will happen if it can escape, and neither if the try_follow isn't working)
[ try_move:> no con:1:>            add col_move:>   | player_move:< ] sfx2 (always has to collide)
[ try_move:> no con:1:> col_move:> add try_follow:> | player_move:> add discard_follow ]
(extra stuff for multiple push directions, WIP)
[ try_move:> no con:1:> col_move:>                  | player_move:v player add col_move:v ] (player pushing itself perpendicularily)
[ try_move:> no con:1:> col_move:>                  | player_move:^ player add col_move:^ ] (player pushing itself perpendicularily)
[ try_move:> no con:1:> col_move:> add try_follow:> | player_move:perpendicular add discard_move:> discard_follow ] (tail won't follow, if present)

(object pushing into tail of moving block)
(the entire tail will be pushed and not follow the try_move)
[ try_move:> no con:1:> | follow:dirs no pusher add discard_follow ] (WIP, is the 'no pusher' really enough?)

(conflict at empty tile, which is moved into from multiple directions)
[ try_move:> | no block gp_items add try_move_dest:> ]
[ add col_move:> | try_move_dest:> try_move_dest:perpendicular/try_move_dest:< ] sfx2
[ was try_move_dest:dirs ]

(conflict at non-block-moving tile pushed into multiple directions)
[ try_move:> try_move:^ no follow:dirs player_move:dirs add col_move:> col_move:^ ] sfx2
[ try_move:> try_move:< no follow:dirs player_move:dirs add col_move:> col_move:< ] sfx2

(stop all pushing that can't happen due to a conflict)
(in front)
[ col_move:>     | try_move:> no player_move:> col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no player_move:> col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< no player_move:dirs add discard_move:dirs ]

(behind conflicts, spread collision. these tiles will show a collision animation.)
(try_follow will be cancelled)
(discard_follow will be spread, which can cause additional try_moves to fail, leading to more discard_follow)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:1:> | con:1:< add col_move:dirs ]
+ dirs [ follow:> add discard_follow | player_move:dirs col_move:dirs ]
+ [ discard_follow con:1:> | con:1:< no player add discard_follow ] (spread, including from block head)
+ [ player_move:dirs was discard_follow ] (but don't leave on block head)
+ [ discard_follow was try_follow:dirs ]
+ [ try_follow:> add col_move:> | player_move:> col_move:dirs ]
+ [ try_follow:> add col_move:> | discard_follow ]

(clear the movement)
[ col_move:> del push:>/player_move:> ]
[ discard_move:> del push:>/player_move:> ]

(block can move)
[ follow:> no discard_follow add player_move:> ]

(don't visualize multi-directional collision)
[ was col_move:> col_move:v ]
[ was col_move:> col_move:< ]

(don't add to the undo queue if the player collided)
[ player col_move:> ] -> nosave

(remove temp markers used in the movement planning, which is now over)
[ was follow:dirs/discard_move:dirs/discard_follow/try_move:dirs/try_follow:dirs ]


(MOVE CAN HAPPEN)
(sound)
[ player_move:dirs ] -> sfx0 (sound)

(actually do the movement)
(use markers to move all items in those tiles)
startloop
  [     push:> was gp_block | no push:dirs player_move:dirs add gp_block ]
  [ was push:>  no gp_block | no push:dirs player_move:dirs add was_pushed:> ] sfx3 (pushed)
  [     player_move:> was gp_block | no push:dirs player_move:dirs add gp_block ]
  [ was player_move:>  no gp_block | no push:dirs player_move:dirs add was_player_moved:> ]
endloop

(fix the connections of the turning pieces)
(former "forward" connection should now point at the front again)
(if that one already exist, just keep it)
dirs [ was_player_moved:< | was_player_moved:dirs                                     is con:1:< add fixed_tail_con:< ]
dirs [ was_player_moved:< | was_player_moved:dirs no fixed_tail_con:< was con:1:dirs add con:1:< add fixed_tail_con:< ]
(cut at end faces backwards)
dirs [ was_player_moved:< no pusher was con:0:dirs add con:0:> | no fixed_tail_con:< ]
(unchanged connections face backwards)
dirs [ was_player_moved:< no fixed_tail_con:dirs was con:1:dirs add con:1:> fixed_tail_con:> ]
[ was fixed_tail_con:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects)
[ was_pushed:dirs/was_player_moved:dirs con:0:> | con:0:< no was_pushed:dirs was_player_moved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound)
[ was_pushed:dirs/was_player_moved:dirs was con:1:> add con:0:> | no con:1:< ] sfx1
[ was con:1:> add con:0:> | no con:1:< was_pushed:dirs/was_player_moved:dirs ] sfx1

(regenerate entry/ exit)
[ room_entry/room_exit no block add block con:1:> | block add con:1:< ]

(remove markers for actually doing the movement)
[ was was_pushed:dirs/was_player_moved:dirs ]


(AFTER MOVE IS DONE)

(reconnect cuts)
[ was con:0:> add con:1:> | was con:0:< add con:1:< ]

(find which multiblocks are partially not over a hole)
[ was supported ]
[ block no hole add supported ]
[ supported con:1:> | con:1:< add supported ]

(the rest fall into hole)
[ hole block no supported add again_gravity ]
[ hole gp_items no again_fly:dirs now_fly:dirs supported add again_gravity ]



(=====================================================================================)
subroutine handle_player_movement

(fall into meta pipes)
(don't fall in when currently spawning, about to fly out or flying out.)
[ player room_exit/room_entry block no con:x:v con:x:^ con:x:< again_entry now_fly:> again_fly:> add again_exit ]

(reset player direction if not valid)
[ player block no con:x:< ] [ was player_facing:> add player_facing:v ] 


(FLY)

(check what should fly this turn) 
(do something with each flying item now)

(hit block end)
[ player   block room_exit/room_entry no con:x:> was now_fly:> ] (stop before falling in the next turn)
[ gp_items block                      no con:x:> was now_fly:> add col_head:> ] sfx7 (soft collision)

(hit wall/ block)
[ gp_items was now_fly:> add col_item:> try_bounce | wall ] sfx0 (movement click)
[ gp_items was now_fly:> add col_item:> try_bounce | block no con:x:< add col_move:> ] sfx0

(hit other flying item/ stationary item)
[ gp_items was now_fly:> add again_fly:<           | gp_items was now_fly:<   add again_fly:> ] sfx0 (what about a perpendicular one? WIP)
[ gp_items was now_fly:> add col_item:> try_bounce | gp_items is now_fly:dirs                 ] sfx0
[ gp_items was now_fly:> add col_item:> try_bounce | gp_items no now_fly:dirs add again_fly:> ] sfx0
[ gp_items was now_fly:> add col_item:> try_bounce | pusher                   add col_head:>  ] sfx7 (can't enter pusher pipe)

(identify tiles multiple items want to fly to)
[ was try_fly_dest:dirs ] (clean the markers from last time)
[ gp_items now_fly:> | add try_fly_dest:> ]
[ was try_fly_dest:> was try_fly_dest:</try_fly_dest:perpendicular ]
(bounce those items back instead)
[ gp_items was now_fly:> add again_fly:< | no try_fly_dest:> ]

(instead of colliding in place, player item will always bounce back)
[ player was col_item:> try_bounce add again_fly:< ]
[ was try_bounce ]

(default flying:)
(move to empty space)
[ was gp_items now_fly:> | no gp_items now_fly:dirs add gp_items again_fly:> ]


(FLYING DONE)

(player faces direction of flying)
[ player again_fly:> ] [ was player_facing:dirs add player_facing:> ]

(spread collisions from bumping into items through flight ... unlike other collision this is only for the directly hit blocks)
dirs [ col_move:dirs con:1:> | add col_move:dirs ]



(=====================================================================================)
subroutine redraw_visuals
(----VISUAL ONLY----)

[ was gp_temporary_visuals ]

(show block)
[ block add vs_block_base ]

(outline towards other connected block part)
[ con:1:> add vs_con_lowest:> ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ con:0:> | was stationary.wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(clean edge on sides without cut/con)
[ block no con:x:> add vs_block_edge:> ]

(add decoration to center of block with exactly one rail)
[ block con:x:> no con:x:v con:x:^ con:x:< add vs_con_end ]

(pusher at block end, points at tail)
[ pusher con:x:> no con:x:v con:x:^ con:x:< add vs_pusher:> ]

(direction for eye)
[ player_facing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( meta connections - show as filled when entering the level and hide the player )
[ room_entry/room_exit con:x:> no con:x:v con:x:^ con:x:< add vs_exit:< ]
[ again_entry/again_exit was vs_exit:> add vs_exit_closed:> del vs_player:dirs ]

(bigger player sprite if at end)
[ block no con:x:v con:x:^ con:x:> room_exit room_entry was vs_player:> add vs_player_end:> ]


(ACTIVATE COLLISION VARIANTS)

(always animate items on a colliding block cell)
[ gp_items col_move:>/col_head:> add col_item:> ]

(animate tiles in collision by replacing them with offset variants)
[ col_move:> was vs_block_base add vs_block_base:> ] 
[ col_move:> was vs_con_end    add vs_con_end:> ] 

dirs [ col_item:> was vs_player:dirs      add vs_player:dirs:> ]
dirs [ col_item:> was vs_player_end:dirs  add vs_player_end:dirs:> ]
dirs [ col_move:> was vs_pusher:dirs      add vs_pusher:dirs:> ]
dirs [ col_head:> was vs_pusher:dirs      add vs_pusher:dirs:> ]
dirs [ col_move:> was vs_con_lowest:dirs  add vs_con_lowest:dirs:> ]
dirs [ col_move:> was vs_block_edge:dirs  add vs_block_edge:dirs:> ]
dirs [ col_move:> was vs_exit:dirs        add vs_exit:dirs:> ]
dirs [ col_move:> was vs_exit_closed:dirs add vs_exit_closed:dirs:> ]

dirs x [ col_move:> was con:x:dirs add con:x:dirs:> ]

(extend forwards)
[ col_head:> is vs_con_end add vs_block_col:> ] 

(can remove markers now, make sure the again turn to undo the visual is queued)
[ was col_move:dirs/col_item:dirs/col_head:dirs add again_col ]



(=====================================================================================)
subroutine queue_again
(----START AGAIN TURNS----)

(fall into hole/exit)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_entry ] -> sfx8 again (appear sound)

(fly again/ end collision animation)
[ again_fly:>/again_col ] -> again

(% endfilter %)