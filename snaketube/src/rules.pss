(% filter relaxRules %)

(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(after collision animation, swap some tiles back)
(all other animated tiles are reset every turn anyway)
dirs x [ again_col ] [ was con:x:dirs:offs add con:x:dirs ]
[ was again_col ]

(gravity)
[ hole again_gravity del block con:x:dirs pusher ] (always remove these)
[ hole again_gravity no again_fly:dirs was gp_items ] (items get removed if not flying)
[ was again_gravity ]

(queued moves)
[ was again_move:> add snake_move:> ]
(queued flying)
[ con:x:v no con:x:> was again_fly:>    add now_fly:v ] (reorient in a pipe corner)
[ con:x:^ no con:x:> was again_fly:>    add now_fly:^ ] (reorient in a pipe corner)
dirs [           was again_fly:dirs add now_fly:dirs ]

(appearing from spawn)
(respawn after trying to go back)
[ con:x:> was again_spawn add again_fly:> player_facing:> player ]
(win level when exiting through meta exit)
[ meta_exit  was player again_exit ] win
(if going back to spawn, player disappears and comes back later)
[ spawnpoint was player again_exit add again_spawn ]


(----INIT----)
(do these at the start of the first turn, then never again)

(arrows)
[ init ] [ spawnpoint con:0:< | wall add vs_meta_arrow:< ]
[ init ] [ meta_exit  con:0:< | wall add vs_meta_arrow:> ]

(connect walls)
[ init ] [ wall add vs_wall_con:> ]
[ init ] [ wall was vs_wall_con:> | no wall ]

(wall edge)
[ init ] [ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]

[ init ] [ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(decoration)
[ init ] [ wall_deco_s was vs_wall_inner:> add vs_wall_deco_s:> ]
[ init ] [ wall_deco_m was vs_wall_inner:> add vs_wall_deco_m:> ]

(put screen_border in bottom left edge)
[ was stationary.init add action.init ] [ add screen_border ] (do once)
down [ init ] [ was screen_border | add screen_border ]

(hole border)
[ init ] [ hole add vs_hole_edge_1:> vs_hole_edge_2:> | no hole ]
[ init ] [ hole no vs_hole_edge_2:^ | was vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:^ | hole no vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:< vs_hole_edge_1:^ add vs_hole_outer_corner:^ ]
[ init ] [ hole no vs_hole_edge_1:> vs_hole_outer_corner:> | no hole add vs_hole_inner_corner:^ ]

(from a spawnpoint, the player appears)
[ init ] [ spawnpoint player add again_spawn ]

(remove init) 
[ was init ]



(----PLAYER INPUT---)

(all moves start from within a block)
(move to empty side starts flight, this same turn)
[ con:x:> was >.player add stationary.player now_fly:> ] [ was player_facing:dirs add player_facing:> ]

(move outside of block starts flight, but only in backwards direction)
[ vs_player:< no con:x:dirs was >.player add stationary.player now_fly:>  ] [ was player_facing:dirs add player_facing:> ]
[             no con:x:dirs was >.player add stationary.player col_item:> ] sfx2

(move forward starts block movement)
[ was >.player add stationary.player snake_move:> ] [ was player_facing:dirs add player_facing:> ]

(in addition to player movement, some moves by other objects can be queued from the last turn)
(see again section at the top)



(----MOVE OBJECTS----)

( 
- a block with a snake_move moves as the head of a snake
- multiblocks and items in front get pushed
- tails and inhabitated heads of snakes can split and are not actually connected for pushing. the tail only follows via snake_move
- collisions or conflicts (multiple attempts to move into same tile) will prevent movement from happening, collision animation will show the problem.
- collisions are cashed so that auto-moving snakes don't try the same movement over and over and refreshed when needed.
- actual movement transfers everything in those tiles over, tile by tile
)

(INITIAL MOVE)
(push block/ item in front)
[ snake_move:> | block    add push:> ]
[ snake_move:> | gp_items add item_push:> ]


(SPREAD PUSH MARKERS)

(push markers do not spread through connections if one side is a source of an active snake)
(detect these tiles first)
[ gp_items/pusher con:x:> no con:x:< con:x:v con:x:^ add snake_source ]

(items and blocks can push each other, unless there is an open side and they won't collide)
dirs [ push:dirs con:1:> no snake_source | con:1:< no snake_source add push:dirs ] (through multiblocks)
+ [ push:<       con:1:> no snake_source | con:1:< pusher          add push:<    ] (can drag pusher along even if not snake movement)
    (above is a WIP. a sideways pusher will still fall off when the rest is involved in a self push.)
    (at the same time, I *want* it to fall off when it's a self snake move but an outside push, I think.)
    (because in that case there is a conflict, which is what the splitting is there to resolve.)
    (it might also be cool to make a failed pusher actually push from the back when it can't snake at the front?)
+ [ push:>            | block            add push:>      ] (block to block)
+ [ push:> no con:x:> | gp_items         add item_push:> ] (closed block to item outside)
+ [ item_push:>       | gp_items         add item_push:> ] (item to item)
+ [ item_push:>       | block no con:x:< add push:>      ] (item outside to closed block)
+ [ push:> gp_items   no con:x:< add item_push:> ] (item inside pushed block)
+ [ item_push:> block no con:x:> add push:>      ] (block around pushed item)

(count item pushes as any other push from now on)
[ no block was item_push:> add push:> ]
[ was item_push:> ]

(a pusher tail pushing itself will not have snake movement, as it can't split and the rest also gets pushed)
[ push:dirs no snake_source was snake_move:dirs ]


(COLLISION)
[ was try_move:dirs ]
[ push:>/snake_move:> add try_move:> ]

(with wall)
[ try_move:> add col_move:> | wall ] sfx2 (collision sound)

(spread collision)
(backpropagate collision markers, these will animate with bounce)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:1:> | con:1:< add col_move:dirs ]

(forward propagate stopping movement on the blocks that weren't going to be pushed anyway)
(these won't show bump anim)
[ col_move:>     | try_move:> no col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< add discard_move:dirs ]

(remember collisions and no longer check these for conflicts, as they already won't move)
[ col_move:> add col_cache:> del try_move:> push:> snake_move:> ]
[ discard_move:>             del try_move:> push:> snake_move:> ]
[ was discard_move:dirs ]


(CONFLICTS)

(only movements that didn't collide into wall are left)
(here we handle:
  - simultanious movement into the same spot
  - objects pushed into multiple directions at once
  - removing follow markers on pushed blocks since they separate from the snake head
)

(add follow markers inside moving snakes that point to the tile nearer to the front)
[ con:1:> snake_move:dirs | snake_move:dirs ] -> log connected adjacent snake movers!
[ con:1:> no follow:dirs snake_move:dirs add follow:> | con:1:< snake_move:dirs/follow:dirs ]

(potential conflict: object pushing into a single-tile moving block)
(if the moving block can actually move and doesn't have its own conflict, then the object will have room to move into it.)
(the try_follow:> markers are placed for now so this will be checked later)
(no pushing through the block head will happen if it can escape, and neither if the try_follow isn't working)
[ try_move:> no con:1:>            add col_move:>   | snake_move:<             add conflict_cache:> ] sfx2 (always has to collide)
[ try_move:> no con:1:> col_move:> add try_follow:> | snake_move:>             add discard_follow ]
[ try_move:> no con:1:> col_move:> add try_follow:> | snake_move:perpendicular add discard_move:> discard_follow ] (tail won't follow, if present)

(object pushing into tail of moving block)
(fine if it's into eg. a pusher, it will just split and not follow)
[ try_move:> no con:1:> | was follow:dirs snake_source ]
(otherwise, the entire tail will be pushed and not follow the try_move)
[ try_move:> no con:1:> | follow:dirs add discard_follow ]

(conflict at empty tile, which is moved into from multiple directions)
[ try_move:> | no block gp_items add try_move_dest:> ]
[ try_move_dest:> try_move_dest:^ add conflict_cache:> conflict_cache:^ ]
[ try_move_dest:> try_move_dest:< add conflict_cache:> conflict_cache:< ]
[ add col_move:> | try_move_dest:> conflict_cache:> ] sfx2
[ was try_move_dest:dirs ]

(conflict at non-block-moving tile pushed into multiple directions)
[ try_move:> try_move:^ no follow:dirs snake_move:dirs add col_move:> col_move:^ ] sfx2
[ try_move:> try_move:< no follow:dirs snake_move:dirs add col_move:> col_move:< ] sfx2

(stop all pushing that can't happen due to a conflict)
(in front)
[ col_move:>     | try_move:> no snake_move:> col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no snake_move:> col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< no snake_move:dirs add discard_move:dirs ]

(behind conflicts, spread collision. these tiles will show a collision animation.)
(try_follow will be cancelled)
(discard_follow will be spread, which can cause additional try_moves to fail, leading to more discard_follow)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:1:> | con:1:< add col_move:dirs ]
+ dirs [ follow:> add discard_follow | snake_move:dirs col_move:dirs ]
+ [ discard_follow con:1:> | con:1:< no snake_move:dirs add discard_follow ] (spread, including from block head)
+ [ snake_move:dirs was discard_follow ] (but don't leave on block head)
+ [ discard_follow was try_follow:dirs ]
+ [ try_follow:> add col_move:> | snake_move:>   col_move:dirs add conflict_cache:> ]
+ [ try_follow:> add col_move:> | discard_follow add conflict_cache:> ]

(cache these added collisions behind the conflicts)
[ try_move:> col_move:> add col_cache:> conflict_cache:> ]

(clear the movement)
[ col_move:> del push:>/snake_move:> ]
[ discard_move:> del push:>/snake_move:> ]

(block can move)
[ follow:> no discard_follow add snake_move:> ]

(don't visualize multi-directional collision)
[ was col_move:> col_move:v ]
[ was col_move:> col_move:< ]

(don't add to the undo queue if the player collided)
[ player col_move:> ] -> nosave

(remove temp markers used in the movement planning, which is now over)
[ was follow:dirs/discard_move:dirs/discard_follow/try_move:dirs/try_follow:dirs/snake_source ]



(MOVE CAN HAPPEN)
(sound)
[ snake_move:dirs ] -> sfx0 (sound)


(REFRESH COLLISION AND CONFLICT CACHE)

(refresh collision and conflict markers at push)
dirs [ push:>/snake_move:> col_cache:dirs      add refresh_cache:dirs ]
dirs [ push:>/snake_move:> conflict_cache:dirs add refresh_cache:dirs ]

(refresh collision marker behind already refreshed collision marker)
(refresh collision marker behind already refreshed conflict marker of any direction)
(refresh conflict marker in front of already refreshed collision marker)
  [ col_cache:> add refresh_cache:> | refresh_cache:> ]
+ [ col_cache:> add refresh_cache:> | refresh_cache:dirs conflict_cache:dirs ]
+ [ col_cache:> refresh_cache:> | conflict_cache:> add refresh_cache:> ]
+ dirs [ con:1:> refresh_cache:dirs | con:1:< add refresh_cache:dirs ] (spread through multiblocks)

[ refresh_cache:dirs del col_cache:dirs conflict_cache:dirs ]
[ was refresh_cache:dirs ]


(split movement into item and block movement again)
[ push:>/snake_move:> gp_items add item_push:> ]
[ gp_items no block was push:> ]


(actually do the movement)
(use markers to move all items in those tiles)

(items and their flying movement)
startloop
       [ item_push:> was gp_items     | no item_push:dirs add gp_items ]
  dirs [ item_push:> was now_fly:dirs | no item_push:dirs add now_fly:dirs ]
  [ was item_push:>  no gp_items      | no item_push:dirs add was_item_pushed:> ]
endloop

(block parts)
startloop
  [     push:> was gp_block | no push:dirs snake_move:dirs add gp_block ]
  [ was push:>  no gp_block | no push:dirs snake_move:dirs add was_pushed:> ] sfx3 (pushed)
  [     snake_move:> was gp_block | no push:dirs snake_move:dirs add gp_block ]
  [ was snake_move:>  no gp_block | no push:dirs snake_move:dirs add was_snake_moved:> ]
endloop

(item pushed sound)
[ was_item_pushed:dirs no was_snake_moved:dirs ] sfx3 (pushed)

(move done:)

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ was_snake_moved:< | was_snake_moved:dirs                                     is con:1:< add fixed_tail_con:< ]
dirs [ was_snake_moved:< | was_snake_moved:dirs no fixed_tail_con:< was con:1:dirs add con:1:< add fixed_tail_con:< ]
(cut at end faces backwards)
dirs [ was_snake_moved:< was con:0:dirs add con:0:> | no fixed_tail_con:< ]
(unchanged connections face backwards)
dirs [ was_snake_moved:< no fixed_tail_con:dirs was con:1:dirs add con:1:> fixed_tail_con:> ]
[ was fixed_tail_con:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ was_pushed:dirs/was_snake_moved:dirs con:0:> | con:0:< no was_pushed:dirs was_snake_moved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ was_pushed:dirs/was_snake_moved:dirs was con:1:> add con:0:> | no con:1:< ] sfx1
[ was con:1:> add con:0:> | no con:1:< was_pushed:dirs/was_snake_moved:dirs ] sfx1

(moved item starts flying if there is space)
[ gp_items was_snake_moved:> was_item_pushed:dirs con:x:> no again_fly:dirs add again_fly:> | no gp_items ]
[ gp_items was_item_pushed:> con:x:>         no again_fly:dirs add again_fly:> ]
[ gp_items was_item_pushed:> con:0:< con:x:v no again_fly:dirs add again_fly:v ]
[ gp_items was_item_pushed:> con:0:< con:x:^ no again_fly:dirs add again_fly:^ ]
[ gp_items was_item_pushed:> no block        no again_fly:dirs add again_fly:> ]
(immediately remove if it can't actually fly, only push)
[ gp_items was_item_pushed:> was again_fly:> | block no con:x:< ]
(prevent item flying into player in a closed block)
[ gp_items was_snake_moved:dirs was again_fly:> | block gp_items ]

(for snake_moved, perpendicular is fine too, as in when an item was dragged around a corner of the block)
[ was_snake_moved:perpendicular was_item_pushed:dirs con:x:> gp_items no again_fly:dirs add again_fly:> | no gp_items ]

(if cut was moved into item, the item moves the other way)
[ was_pushed:> con:0:> gp_items no was_item_pushed:dirs again_fly:dirs add again_fly:< ]

(remove markers for actually doing the movement)
[ was was_pushed:dirs/was_snake_moved:dirs/was_item_pushed:dirs ]



(----AFTER MOVE IS DONE----)

(reconnect cuts)
[ was con:0:> add con:1:> | was con:0:< add con:1:< ]

(find which multiblocks are partially not over a hole)
[ was supported ]
[ block no hole add supported ]
[ supported con:1:> | con:1:< add supported ]

(the rest fall into hole)
[ hole block no supported add again_gravity ]
[ hole gp_items no again_fly:dirs now_fly:dirs supported add again_gravity ]

(fall into meta pipes)
(don't fall in when currently spawning, about to fly out or flying out.)
[ player meta_exit/spawnpoint block no con:x:v con:x:^ con:x:< again_spawn now_fly:> again_fly:> add again_exit ]

(reset player direction if not valid)
[ player block no con:x:< ] [ was player_facing:> add player_facing:v ] 



(----FLY----)

(check what should fly this turn) 
(do something with each flying item now)

(hit block end)
[ player   block meta_exit/spawnpoint no con:x:> was now_fly:> ] (stop before falling in the next turn)
[ gp_items block                      no con:x:> was now_fly:> add col_head:> ] sfx7 (soft collision)

(hit wall/ block)
[ gp_items was now_fly:> add col_item:> try_bounce | wall ] sfx0 (movement click)
[ gp_items was now_fly:> add col_item:> try_bounce | block no con:x:< add col_move:> ] sfx0

(hit other flying item/ stationary item)
[ gp_items was now_fly:> add again_fly:<           | gp_items was now_fly:<   add again_fly:> ] sfx0 (what about a perpendicular one? WIP)
[ gp_items was now_fly:> add col_item:> try_bounce | gp_items is now_fly:dirs                 ] sfx0
[ gp_items was now_fly:> add col_item:> try_bounce | gp_items no now_fly:dirs add again_fly:> ] sfx0
[ gp_items was now_fly:> add col_item:> try_bounce | pusher                   add col_head:>  ] sfx7 (can't enter pusher pipe)

(identify tiles multiple items want to fly to)
[ was try_fly_dest:dirs ] (clean the markers from last time)
[ gp_items now_fly:> | add try_fly_dest:> ]
[ was try_fly_dest:> was try_fly_dest:</try_fly_dest:perpendicular ]
(bounce those items back instead)
[ gp_items was now_fly:> add again_fly:< | no try_fly_dest:> ]

(instead of colliding in place, player item will always bounce back)
[ player was col_item:> try_bounce add again_fly:< ]
[ was try_bounce ]

(default flying:)
(move to empty space)
[ was gp_items now_fly:> | no gp_items now_fly:dirs add gp_items again_fly:> ]


(----FLYING DONE----)

(player faces direction of flying)
[ player again_fly:> ] [ was player_facing:dirs add player_facing:> ]

(spread collisions ... note, this doesn't also show up on multipushed blocks)
dirs [ col_move:dirs con:1:> | add col_move:dirs ]

(----QUEUE PUSHES FROM MOVERS----)

(find multiblocks that could move due to npc)
(if there was already an attempt that collided, the collision is cached.)
(it is updated if a relevant part of the collided blocks was moved.)
[ block con:x:< npc no again_gravity again_fly:< con:x:v con:x:^ con:x:> col_cache:> conflict_cache:> add again_move:>  ]

(pushers work when they have at least one tail segment attached and move towards it)
[ was pusher_destination ]
[ block pusher con:1:> | add pusher_destination ]
[ block pusher_destination con:1:> | no pusher add pusher_destination ]
[ block pusher_destination no con:x:> con:x:^ con:x:v again_gravity col_cache:> conflict_cache:> add again_move:> ]
[ block pusher_destination    con:0:>              no again_gravity col_cache:> conflict_cache:> add again_move:> ]

(----END OF TURN----)



(----VISUAL ONLY----)

[ was gp_temporary_visuals ]

(show block)
[ block add vs_block_base ]

(outline towards other connected block part)
[ con:1:> add vs_con_lowest:> ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ con:0:> | was stationary.wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(clean edge on sides without cut/con)
[ block no con:x:> add vs_block_edge:> ]

(add decoration to center of block with exactly one rail)
[ block con:x:> no con:x:v con:x:^ con:x:< add vs_con_end ]

(npc at block end)
[ npc block con:x:< no con:x:v con:x:^ con:x:> again_fly:< add vs_npc:> ]
[ npc no vs_npc:dirs add vs_npc_off ]

(pusher at block end, points at tail)
[ pusher block con:x:> no con:x:v con:x:^ con:x:< add vs_pusher:> ]

(direction for eye)
[ player_facing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( meta connections - show as filled when entering the level and hide the player )
[ spawnpoint/meta_exit con:x:> no con:x:v con:x:^ con:x:< add vs_meta_pipe:< ]
[ again_spawn/again_exit was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

(bigger player sprite if at end)
[ block no con:x:v con:x:^ con:x:> meta_exit spawnpoint was vs_player:> add vs_player_end:> ]


(----ACTIVATE COLLISION VARIANTS----)

(always animate items on a colliding block cell)
[ gp_items col_move:>/col_head:> add col_item:> ]

(animate tiles in collision by replacing them with offset variants)
[ col_item:> was vs_npc_off add vs_npc_off:> ]

dirs [ col_item:> was vs_player:dirs     add vs_player:dirs:> ]
dirs [ col_item:> was vs_player_end:dirs add vs_player_end:dirs:> ]
dirs [ col_item:> was vs_npc:dirs        add vs_npc:dirs:> ]

[ col_move:> was vs_block_base add vs_block_base:> ] 
[ col_move:> was vs_con_end    add vs_con_end:> ] 

dirs x [ col_move:> was con:x:dirs add con:x:dirs:> ]

dirs [ col_move:> was vs_con_lowest:dirs       add vs_con_lowest:dirs:> ]
dirs [ col_move:> was vs_block_edge:dirs       add vs_block_edge:dirs:> ]
dirs [ col_move:> was vs_meta_pipe:dirs        add vs_meta_pipe:dirs:> ]
dirs [ col_move:> was vs_meta_pipe_closed:dirs add vs_meta_pipe_closed:dirs:> ]
dirs [ col_move:> was vs_pusher:dirs           add vs_pusher:dirs:> ]

(extend forwards)
[ col_head:> is vs_con_end add vs_block_col:> ] 


(----START AGAIN TURNS----)

(fall into hole/exit after shown over it)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_spawn ] -> sfx8 again (appear sound)

(fly again)
[ again_fly:> gp_items ] -> again

(move multiblock after there was space for it)
[ again_move:> ] -> again

(to go back from the collision animation to default state)
[ was col_move:dirs/col_item:dirs/col_head:dirs add again_col ] again

(% endfilter %)