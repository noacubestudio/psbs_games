(----INIT----)
(do these at the start of the turn, then remove the init marker.)

(connect any snakes in level)
[init] [snake no init_conBnotA no init_noMoreCon no cut:> | snake no init_conBnotA no cut:< no init_noMoreCon] -> [init] [snake con:> | con:< snake]
[init] [snake no init_conAnotB no init_noMoreCon no cut:> | snake no init_conAnotB no cut:< no init_noMoreCon] -> [init] [snake con:> | con:< snake]
[init] [player con:> | con:< init_connectRules] -> [init] [player | ]

(connect tracks, tracks = solid pipes in walls)
[init] [track | track] -> [init] [track trc:> | track]
[init] [track no init_noMoreCon | no wall] -> [init] [track trc:> | ]
[init] [track | border] -> [init] [track trc:> | border]
(add ends of tracks)
[init] [trc:> | no trc:< no win no border] -> [init] [trc:> vs_trackcut:> | ]

(wall border)
[init] [wall no border no trc:> | no wall] -> [init] [wall vs_shadow:> vs_wall_edge:> | ]
[init] [vs_shadow:v | wall no track no vs_shadow:v] -> [init] [vs_shadow:v | wall vs_wall_corner:>]
[init] [vs_trackcut:v | wall no track no vs_shadow:v] -> [init] [vs_trackcut:v | wall vs_wall_corner:>]
(hole border)
[init] [no border no hole no bridge] -> [init] [floor]
[init] [floor | hole] -> [init] [floor | vs_hole_edge:< hole]
[init] [floor no wall | hole] -> [init] [floor vs_floor_hole_shadow | hole]
[init] [floor trc:> | hole] -> [init] [floor trc:> vs_floor_hole_shadow | hole]
[init] [floor wall no trc:> | hole] -> [init] [floor wall vs_wall_hole_shadow | hole]

(level border rounded corners)
vertical [init] [border | no border no vs_border_corner:vertical] -> [init] [border | vs_border_corner:< vs_border_corner:^]
[init] [no border | vs_border_corner:dirs | no border] -> [init] [ | | ]
[init] [vs_border_corner:^ | border] -> [init] [ | border]
[init] [vs_border_corner:< | border] -> [init] [ | border]

(starting direction eye is facing)
[init player con:> no con:<] -> [init playerFacing:> player con:>]
[init player trc:> no trc:<] -> [init playerFacing:> player trc:>]

(also set move direction to start with here)
[init] [border | trc:< player] -> [init playerFacing:>] [border player again_fly:> | trc:<]

(end init) 
(start of first player turn or again turn ends init)
[init] [> player] -> [playerFacing:>] [> player] 
[init] [again_fly:>] -> [] [again_fly:>]

(------------------)

(on every player turn after, also reorient the playerFacing marker)
[> player] [playerFacing:dirs] -> [> player] [playerFacing:>]
(init stuff I can't remove earlier, not sure why)
[> player] [init_conBnotA]  -> [> player] []
[> player] [init_conAnotB]  -> [> player] []
[> player] [init_noMoreCon] -> [> player] []



(----AGAIN TURN----)
(these are in a previously started again turn)

(stuff on snake falls into hole)
(ball and player fall into hole if not flying)
dirs [any:dirs   again_gravity hole             ] -> [again_gravity hole vs_bridge_con:dirs]
[it_canFall again_gravity hole                  ] -> [again_gravity hole]
[ball       again_gravity hole no again_fly:dirs] -> [again_gravity hole vs_bridge_dot]
[player     again_gravity hole no again_fly:dirs] -> [again_gravity hole vs_bridge_dot]
(replace snake and hole itself with bridge tile)
[snake again_gravity hole] -> [bridge]


(update edge of hole)
[bridge |      hole] -> [bridge vs_floor_hole_shadow | hole vs_hole_edge:<]
[bridge | no bridge] -> [bridge vs_hole_edge:> | ]
(connect bridges)
([bridge no vs_hole_edge:> | no vs_hole_edge:< bridge] -> [bridge vs_bridge_con:> | bridge vs_bridge_con:<])

(revert collision)
(swap the shifted collision anim objects out with the regular ones)
(other objects get regenerated every turn anyway & don't need to be swapped back here)
[again_col] [snake:offs            ] -> [again_col] [snake]
[again_col] [ball:offs             ] -> [again_col] [ball]
dirs [again_col] [con:dirs:offs         ] -> [again_col] [con:dirs]
dirs [again_col] [cut:dirs:offs         ] -> [again_col] [cut:dirs]
dirs [again_col] [brokenplayer:dirs:offs] -> [again_col] [brokenplayer:dirs]
dirs [again_col] [brokenball:dirs:offs  ] -> [again_col] [brokenball:dirs]
[again_col] -> []



(----SET AT START OF ROUND ---)

(any markers, these are used to sometimes ignore which kind of connections are actually present)
(but record the directions of connection for later in the turn)
[any:dirs] -> []
[con:>] -> [con:> any:>]
[cut:>] -> [cut:> any:>]
[trc:>] -> [trc:> any:>]



(----PLAYER INPUT---)

(move out of connector starts slide)
[> player any:>] -> [player any:> again_fly:>]

(pilot a snake)
[> player] -> [player turnMove:>]



(----FLY----)

(reorient sliding direction based on pipe around)
(the stationary makes sure they can only do this once)
(if anything else, like pushing leads to flying, on the initial turn this isn't done...)
[stationary again_fly:> any:v no wasMoved:>] -> [v again_fly:v any:v]
[stationary again_fly:> any:^ no wasMoved:>] -> [^ again_fly:^ any:^]
(reset temporary marker)
[again_fly:dirs] -> [stationary again_fly:dirs]


(check what should happen this turn) 
(if there's a match, skip all remaining cases using a temporary action marker)

(if flying into snake end, steer)
[stationary again_fly:> it_canFly snake no any:>] -> [anim_col:> it_canFly snake]
(if flying into level border, remove)
[stationary again_fly:> player | border no win] -> [ | border]
[stationary again_fly:> ball   | border       ] -> [ | border]
(if flying into wall, remove and leave broken effect)
[stationary again_fly:> player | wall no any:<] -> [ | brokenplayer:< wall] sfx6 (breaking sound)
[stationary again_fly:> ball   | wall no any:<] -> [ | brokenball:<   wall] sfx6 (breaking sound)
(if flying into snake, try to push the snake)
[stationary again_fly:> player | snake no any:<] -> [ | brokenplayer:< snake move:>] sfx6 (breaking sound)
[stationary again_fly:> ball   | snake no any:<] -> [ | brokenball:<   snake move:>] sfx6 (breaking sound)
(if flying into another flying object, both repel)
[stationary again_fly:> it_canFly | stationary again_fly:< it_canFly] -> [action again_fly:< it_canFly | action again_fly:> it_canFly] sfx7
(if flying into stationary object at snake end, repel and steer)
[stationary again_fly:> it_canFly | it_canFly snake no any:> no any:perpendicular] -> [action again_fly:< it_canFly | it_canFly snake turnMove:>] sfx7
(if flying into stationary object that could move, both repel)
[stationary again_fly:> it_canFly | it_canFly] -> [action again_fly:< it_canFly | action again_fly:> it_canFly] sfx7
(if flying into empty space that another object wants to fly into)
(first place directional markers in the empty space)
[stationary again_fly:> it_canFly | ] -> [stationary again_fly:> it_canFly | wantsToFlyTo:>]
(remove the markers if there is overlap)
[wantsToFlyTo:< wantsToFlyTo:>] -> []
[wantsToFlyTo:> wantsToFlyTo:perpendicular] -> []
(now check for moving into empty space with the marker missing)
[stationary again_fly:> it_canFly | no wantsToFlyTo:>] -> [action again_fly:< it_canFly | ]
(clear the markers)
[wantsToFlyTo:dirs] -> []
(if flying into any other tile, just move one tile)
[stationary again_fly:> it_canFly | ] -> [ | action again_fly:> it_canFly]


(----FLYING DONE----)

(reset temporary markers)
[again_fly:dirs] -> [stationary again_fly:dirs]

(if flying, set player facing)
[player again_fly:>] [playerFacing:dirs] -> [player again_fly:>] [playerFacing:>]

(spread collisions)
[anim_col:dirs con:> | ] -> [anim_col:dirs con:> | anim_col:dirs]



(----MOVE OBJECTS----)

( 
- starts from a turnMove, i.e. a snakelike move that makes a tile orient itself
- marks all pushing and turning tiles at once, checking if anything collides
- push markers overwrite snake movement, so you can build a contraption to push yourself without turning
- the head pushing into the snake body makes the body split off, because push markers have priority
)

(remove temp from last time)
[wasMoved:dirs] -> []
[wasTurnMoved:dirs] -> []
[follow:dirs] -> [] (just in case)

(propagate forward from a pusher)
[turnMove:> | snake] -> [turnMove:> | snake move:>]

(loop to propagate regular move forward and also through connections whenever possible.)
(in forward direction-so with actual pressure, it can even affect the snake head doing the push, such as in a C shape)
(otherwise, through a connection only spread if there is no turnMove:dirs there)
[move:> | snake] -> [move:> | snake move:>]
+ [move:dirs con:> | con:< no turnMove:dirs] -> [move:dirs con:> | con:< move:dirs] 

(however, IF the shape itself is pushed and it now has both turnMove and move, currently it then spreads to the whole tail.)
(so for now, in that case there should be no snake movement at all and the whole thing just translates.)
[move:dirs] -> [move:dirs no turnMove:dirs]

(so far there are tiles being moved and possibly a head tile with a turnMove.)
(check collision now, show animation and cancel any actual movement if so)
[    move:> | no move:> it_collides] -> [anim_col:> | it_collides] nosave
[turnMove:> | no move:> it_collides] -> [anim_col:> | it_collides] nosave
(collision animation, remove all markers)
dirs [anim_col:>] [turnMove:dirs] -> [anim_col:>] [anim_col:dirs]
dirs [anim_col:>] [move:dirs    ] -> [anim_col:>] [anim_col:dirs]
(also spread through tiles that weren't moved if they are connected)
dirs [anim_col:dirs con:> | con:< no anim_col:dirs] -> [anim_col:dirs con:> | con:< anim_col:dirs]

(add marker to indicate in what direction and where the snake should be followed)
[no move:dirs con:> | con:< turnMove:dirs] -> [follow:> con:> | con:< turnMove:dirs]

(do the movement)
(use markers to move all items in those tiles)
[    move:> it_movesOnSnake | no any_move] -> [    move:> | it_movesOnSnake]
+ [    move:>                 | no any_move] -> [           |      wasMoved:>] sfx3
+ [turnMove:> it_movesOnSnake | no any_move] -> [turnMove:> | it_movesOnSnake] 
+ [turnMove:>                 | no any_move] -> [           |  wasTurnMoved:>]

(add turnMove markers behind the first one, starting from the follow:>)
(exclude anything that already moved)
[     no snake | con:<    follow:<      no wasMoved:dirs no wasTurnMoved:dirs] -> [              | con:< turnMove:<]
[turnMove:dirs | con:< no turnMove:dirs no wasMoved:dirs no wasTurnMoved:dirs] -> [turnMove:dirs | con:< turnMove:<]

(move the tail following the tile )
(this assumes there is always one tile that can move, and moves them in order )
startloop
[turnMove:> it_movesOnSnake | no any_move] -> [turnMove:> | it_movesOnSnake]
random [turnMove:> | no any_move] -> [ | wasTurnMoved:>]
endloop

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [wasTurnMoved:< | wasTurnMoved:dirs con:<]    -> [wasTurnMoved:< | wasTurnMoved:dirs con:< correctConnectDir:<]
dirs [wasTurnMoved:< | wasTurnMoved:dirs con:dirs no correctConnectDir:<] -> [wasTurnMoved:< | wasTurnMoved:dirs con:< correctConnectDir:<]
(if there is another connection or cut, make it face backwards again )
dirs [wasTurnMoved:< con:dirs no correctConnectDir:dirs] -> [wasTurnMoved:< con:> correctConnectDir:>]
dirs [wasTurnMoved:< cut:dirs] -> [wasTurnMoved:< cut:> correctConnectDir:>]
[correctConnectDir:dirs] -> []

(a moved cut next to a stationary one will make a sound because it reconnects )
[    wasMoved:dirs cut:> | cut:< no wasMoved:dirs no wasTurnMoved:dirs] -> sfx5
[wasTurnMoved:dirs cut:> | cut:< no wasMoved:dirs no wasTurnMoved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[    wasMoved:dirs con:> | no con:<] -> [    wasMoved:dirs cut:> | ] sfx1
[wasTurnMoved:dirs con:> | no con:<] -> [wasTurnMoved:dirs cut:> | ] sfx1

(a moved flying item will start flying if there is an open end that direction)
[    wasMoved:> con:> it_canFly no again_fly:dirs] -> [wasMoved:> con:> it_canFly again_fly:>]
[    wasMoved:> cut:> it_canFly no again_fly:dirs] -> [wasMoved:> cut:> it_canFly again_fly:>]
[wasTurnMoved:> con:> it_canFly no again_fly:dirs | no it_canFly] -> [wasTurnMoved:> con:> it_canFly again_fly:> | ]
[wasTurnMoved:> cut:> it_canFly no again_fly:dirs | no it_canFly] -> [wasTurnMoved:> cut:> it_canFly again_fly:> | ]
(for turnMoved, perpendicular is fine too, as in when a ball was dragged around a corner of the snake)
[wasTurnMoved:perpendicular con:> it_canFly no again_fly:dirs | no it_canFly] -> [wasTurnMoved:perpendicular con:> it_canFly again_fly:> | ]
[wasTurnMoved:perpendicular cut:> it_canFly no again_fly:dirs | no it_canFly] -> [wasTurnMoved:perpendicular cut:> it_canFly again_fly:> | ]

(remove effect of broken player/ball if snake was turnmoved)
[wasTurnMoved:> brokenplayer:dirs] -> [wasTurnMoved:>]
[wasTurnMoved:> brokenball:dirs  ] -> [wasTurnMoved:>]

(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those for the next turn)
[any:dirs] -> []
[con:>] -> [con:> any:>]
[cut:>] -> [cut:> any:>]
[trc:>] -> [trc:> any:>]

(reconnect cuts)
[cut:> | cut:<] -> [con:> | con:<]

(find which snake multiblocks are partially not over a hole)
[supported] -> []
[snake no hole] -> [snake supported]
[supported con:> | con:<] -> [supported con:> | con:< supported]
(the rest fall into hole)
[snake no supported] -> [snake again_gravity] 



(----VISUAL ONLY----)

[tempVisualObjects] -> []

(cuts)
[cut:>] -> [cut:> vs_cut_shadow:> vs_cut_base:>]

(tail)
(start tail visual from it_canFly in end position)
[it_canFly snake any:> no any:< no any:perpendicular] -> [it_canFly snake any:> vs_tail:> vs_tail_from:>]
(visualize the tail at the front, if min length 2)
[vs_tail_from:> con:> | ] -> [vs_tail_from:> con:> | vs_tail_to:>]

(shadows)
[any:> snake]     -> [any:> snake     vs_con_shadow:>]
[any:> vs_tail:dirs] -> [any:> vs_tail:dirs vs_tail_shadow:>]
[snake] -> [snake vs_snake_shadow]

(direction for eye)
[playerFacing:>] [player] -> [playerFacing:>] [player vs_player:>]
[player no vs_player:dirs] -> [player vs_player:right]

(design around holes)
[vs_shadow:> | no hole] -> [vs_shadow:> vs_wall_shadow:> | ]
[vs_wall_shadow:> vs_wall_shadow:v] -> [vs_wall_shadow:> vs_wall_shadow:v vs_wall_shadow_corner:>]
[vs_trackcut:> | no hole] -> [vs_trackcut:> | vs_track_floorext:<]

(animate tiles in collision by replacing them with offset variants)
[anim_col:> snake                       ] -> [anim_col:> snake:>]
[anim_col:> ball                        ] -> [anim_col:> ball:>]
[anim_col:> vs_snake_shadow             ] -> [anim_col:> vs_snake_shadow:>]
dirs [anim_col:> con:dirs                    ] -> [anim_col:> con:dirs:>]
dirs [anim_col:> cut:dirs                    ] -> [anim_col:> cut:dirs:>]
dirs [anim_col:> brokenplayer:dirs           ] -> [anim_col:> brokenplayer:dirs:>]
dirs [anim_col:> brokenball:dirs             ] -> [anim_col:> brokenball:dirs:>]
dirs [anim_col:> vs_tail:dirs                ] -> [anim_col:> vs_tail:dirs:>]
dirs [anim_col:> vs_tail_from:dirs           ] -> [anim_col:> vs_tail_from:dirs:>]
dirs [anim_col:> vs_tail_to:dirs             ] -> [anim_col:> vs_tail_to:dirs:>]
dirs [anim_col:> vs_con_shadow:dirs no track ] -> [anim_col:> vs_con_shadow:dirs:>]
dirs [anim_col:> vs_tail_shadow:dirs no track] -> [anim_col:> vs_tail_shadow:dirs:>]
dirs [anim_col:> vs_cut_shadow:dirs          ] -> [anim_col:> vs_cut_shadow:dirs:>]
dirs [anim_col:> vs_cut_base:dirs            ] -> [anim_col:> vs_cut_base:dirs:>]
dirs [anim_col:> vs_cut_tail:dirs            ] -> [anim_col:> vs_cut_tail:dirs:>]
dirs [anim_col:> vs_player:dirs              ] -> [anim_col:> vs_player:dirs:>]



(----START AGAIN TURNS----)

(fall into hole after shown over it)
[again_gravity] -> sfx4 again

(fly again)
[again_fly:> it_canFly] -> again

(to go back from the collision animation to default state)
[anim_col:dirs] -> [again_col] sfx2 again