(% filter relaxRules %)

(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(gravity)
[ hole again_gravity was gpGravity ]
[ hole again_gravity no again_fly:dirs was gpItem ]
[ was again_gravity ]

(queued moves)
[ was again_move:> add snakeMove:> ]
(queued flying)
[ any:v no any:> was again_fly:>    add now_fly:v ] (reorient in a pipe corner)
[ any:^ no any:> was again_fly:>    add now_fly:^ ] (reorient in a pipe corner)
dirs [           was again_fly:dirs add now_fly:dirs ]

(appearing from spawn)
[ con:>/cut:> was again_spawn add again_fly:> playerFacing:> ]
[ was again_spawn add playerFacing:right ] (wip, what is this?)

(win level)
[ was player again_exit ] win

(end collision animation, swap tiles back)
(only for objects that don't get regenerated every turn anyway)
[ again_col ] [ was ball:offs add ball ]
dirs [ again_col ] [ was con:dirs:offs add con:dirs ]
dirs [ again_col ] [ was cut:dirs:offs add cut:dirs ]
[ was again_col ]


(----INIT----)
(do these at the start of the first turn, then never again)

(connect any snakes in level)
[ init ] [ snake no init_conBnotA/init_conAnotB init_noMoreCon cut:> add con:> | snake no init_conBnotA/init_conAnotB init_noMoreCon cut:< add con:< ]
[ init ] [ player was con:> | was con:< init_connectRules ]

(spawnpoints/meta_exit)
[ init ] [ spawnpoint/meta_exit no con:dirs cut:dirs add cut:> | no wall ]

(connect walls)
[ init ] [ wall add vs_wall_con:> ]
[ init ] [ wall was vs_wall_con:> | no wall ]

(wall edge)
[ init ] [ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]

[ init ] [ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(hole border)
[ init ] [ no hole add floor ]
[ init ] [ hole add vs_hole_edge_1:> vs_hole_edge_2:> | floor ]
[ init ] [ hole no vs_hole_edge_2:^ | was vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:^ | hole no vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:< vs_hole_edge_1:^ add vs_hole_outer_corner:^ ]
[ init ] [ hole no vs_hole_edge_1:> vs_hole_outer_corner:> | no hole add vs_hole_inner_corner:^ ]


(from a spawnpoint, the player appears)
[ init ] [ spawnpoint player add again_spawn ]

(remove markers only used for init)
[ init ] [ was init_conAnotB/init_conBnotA/init_noMoreCon ]

(remove init) 
[ was init ]



(----SET AT START OF ROUND ---)

(update group for each direction of both connections and cut ends of pipes)
[ was any:dirs ]
[ con:>/cut:> add any:> ]



(----PLAYER INPUT---)

(all moves start from within a tube)
(move to empty side starts flight, this same turn)
[ any:> was >.player add stationary.player now_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(move outside of snake starts flight, but only in backwards direction)
[ no any:dirs was >.player is vs_player:< add stationary.player now_fly:> ] [ was playerFacing:dirs add playerFacing:> ]
[ no any:dirs was >.player add stationary.player col_item:> ] sfx2

(move forward starts snake movement)
[ was >.player add stationary.player snakeMove:> ] [ was playerFacing:dirs add playerFacing:> ]

(if the player isn't at the end of a snake, block the move)
dirs [ any:> any:v was snakeMove:dirs add col_item:dirs ] sfx2
dirs [ any:> any:< was snakeMove:dirs add col_item:dirs ] sfx2



(----MOVE OBJECTS----)

( 
- a pipe end with a snakeMove moves as the head of the snake
- multiblocks and npcs in front get pushed
- the tail of the snake head follows - if it can not follow, for example because it got pushed or the head got pushed,
  the head will split.
- for any tiles that should do a normal move, collision in checked first so that ALL of them have to work out
- actual movement transfers everything in those tiles over, tile by tile
)

(remove temp markers from last time)
[ was wasMoved:dirs/wasSnakeMoved:dirs/wasItemMoved:dirs/follow:dirs/hasToSplit ]


(INITIAL MOVE)
(push block/ item in front)
[ snakeMove:> | snake  add push:>     ]
[ snakeMove:> | gpItem add itemPush:> ]

(SPREAD PUSH MARKERS)
(items can also push/be pushed by blocks but only if there is no opening there)
  [ snake  push:>              | snake          add push:>     ] (block to block)
+ [ snake  push:>     no any:> | gpItem         add itemPush:> ] (closed block to item outside)
+ [ gpItem itemPush:>          | gpItem         add itemPush:> ] (item to item)
+ [ gpItem itemPush:>          | snake no any:< add push:>     ] (item outside to closed block)
+ dirs [ push:dirs con:> no snakeMove:dirs | con:< add push:dirs ] (whole multiblock, except don't move snake body through head alone)
+ [ snake push:>     gpItem no any:< add itemPush:> ] (item inside pushed block)
+ [ snake itemPush:> gpItem no any:> add push:>     ] (block around pushed item)

(count item pushes as any other push from now on)
[ no snake was itemPush:> add push:> ]
[ was itemPush:> ]

(COLLISION)
(with wall)
[ push:>/snakeMove:> add col_move:> | wall ] sfx2 (collision sound)

(spread collision)
(backpropagate collision markers, these will animate with bounce)
  [      push:> add col_move:> | col_move:> ]
+ [ snakeMove:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:> | con:< add col_move:dirs ]

(if part in front moves in another direction already, then stop moving into it)
[ push:>/snakeMove:> add col_move:> | push:perpendicular ] sfx2
[ push:>/snakeMove:> add col_move:> | snakeMove:perpendicular ] sfx2

(detect conflicts between ones that weren't colliding so far)
[ push:>/snakeMove:> no col_move:> | add wantsToMoveTo:> ]
[ was wantsToMoveTo:> wantsToMoveTo:< ]
[ was wantsToMoveTo:> wantsToMoveTo:^ ]
[ push:>/snakeMove:> no col_move:> add col_move:> | no wantsToMoveTo:> add cached_conflict ] sfx2 (collision sound)
[ was wantsToMoveTo:dirs ]

(spread collision again)
  [      push:> add col_move:> | col_move:> ]
+ [ snakeMove:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:> | con:< add col_move:dirs ]

(forward propagate stopping movement on blocks that couldn't have moved anyway)
[ col_move:> | push:> no col_move:> add discard_move ]
  [ discard_move push:> | push:> no col_move:> add discard_move ]
+ dirs [ discard_move con:> | con:< add discard_move ]

(remove all movement markers on collided tiles) 
[ col_move:>   was push:>/snakeMove:> ]
[ discard_move was push:> ]
[ was discard_move ]

(cache the result of collision)
[ col_move:> add cached_col:> ]

(don't add to the undo queue if the player collided)
[ player col_move:> ] -> nosave

(hide multi-directional ones)
[ was col_move:> col_move:v ]



(MOVE CAN HAPPEN)
(sound)
[ snakeMove:dirs ] -> sfx0 (sound)

(MOVE TAIL OF SNAKE)
(add follow markers along the entire tail that point to each part in front of them)
[ con:> add follow:> | con:< snakeMove:dirs ]
[ con:> no follow:dirs snakeMove:dirs add follow:> | con:< follow:dirs ]

(split head off by removing all follow markers on snake that follows the player if tiles are pushed sideways)
(also split if ONLY the front has a move marker)
[ push:perpendicular follow:> add hasToSplit ] 
dirs [ no push:dirs add hasToSplit con:> | con:< push:dirs ]
[ hasToSplit con:> | con:< del follow:dirs add hasToSplit ]

(add snakeMove markers to snake)
[ was follow:> add snakeMove:> del push:dirs ]

(clean collision cache / cached conflicts)
dirs [ push:>/snakeMove:> was cached_col:dirs add refresh_cache:dirs ]

  [ refresh_cache:> | was cached_col:> add refresh_cache:> ]
+ [ refresh_cache:> | cached_conflict  add refresh_cache:> ]
+ [ was cached_col:> add refresh_cache:> | refresh_cache:> ]
+ [ was cached_col:> add refresh_cache:> | refresh_cache:dirs cached_conflict ]
+ dirs [ con:> was cached_col:dirs add refresh_cache:dirs | con:< refresh_cache:dirs ]

[ was refresh_cache:dirs del cached_conflict ]

(split movement into item and block movement again)
[ push:>/snakeMove:> gpItem add itemPush:> ]
[ gpItem no snake was push:> ]

(actually do the movement)
(use markers to move all items in those tiles)

(items and their flying movement)
startloop
       [ itemPush:> was gpItem       | no itemPush:dirs add gpItem ]
  dirs [ itemPush:> was now_fly:dirs | no itemPush:dirs add now_fly:dirs ]
  [ was itemPush:>  no gpItem        | no itemPush:dirs add wasItemMoved:> ]
endloop

(snake parts)
startloop
  [     push:> was gpSnake | no gpFullBlockMove add gpSnake ]
  [ was push:>  no gpSnake | no gpFullBlockMove add wasMoved:>   ] sfx3 (pushed)
  [     snakeMove:> was gpSnake | no gpFullBlockMove add gpSnake ]
  [ was snakeMove:>  no gpSnake | no gpFullBlockMove add wasSnakeMoved:> ]
endloop

(item pushed sound)
[ wasItemMoved:dirs no wasSnakeMoved:dirs ] sfx3 (pushed)

(move done:)

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs                                      is con:< add correctConnectDir:< ]
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs no correctConnectDir:< was con:dirs add con:< add correctConnectDir:< ]
(if there is another connection or cut, make it face backwards again )
dirs [ wasSnakeMoved:< no correctConnectDir:dirs was con:dirs add con:> correctConnectDir:> ]
dirs [ wasSnakeMoved:<                           was cut:dirs add cut:> correctConnectDir:> ]
[ was correctConnectDir:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ wasMoved:dirs/wasSnakeMoved:dirs cut:> | cut:< no wasMoved:dirs wasSnakeMoved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ wasMoved:dirs/wasSnakeMoved:dirs was con:> add cut:> | no con:< ] sfx1
[ was con:> add cut:> | no con:< wasMoved:dirs/wasSnakeMoved:dirs ] sfx1

(moved item starts flying if there is space)
[ gpItem wasSnakeMoved:> wasItemMoved:dirs con:>/cut:> no again_fly:dirs add again_fly:> | no gpItem ]
[ gpItem wasItemMoved:> con:>/cut:>       no again_fly:dirs add again_fly:> ]
[ gpItem wasItemMoved:> cut:< con:v/cut:v no again_fly:dirs add again_fly:v ]
[ gpItem wasItemMoved:> cut:< con:^/cut:^ no again_fly:dirs add again_fly:^ ]
[ gpItem wasItemMoved:> no snake          no again_fly:dirs add again_fly:> ]
(immediately remove if it can't actually fly, only push)
[ gpItem wasItemMoved:> was again_fly:> | snake no cut:< con:< ]
(prevent item flying into player in a closed snake)
[ gpItem wasSnakeMoved:dirs was again_fly:> | snake gpItem ]

(for snakeMoved, perpendicular is fine too, as in when an item was dragged around a corner of the snake)
[ wasSnakeMoved:perpendicular wasItemMoved:dirs con:>/cut:> gpItem no again_fly:dirs add again_fly:> | no gpItem ]

(if cut was moved into item, the item moves the other way)
[ wasMoved:> cut:> gpItem no wasItemMoved:dirs again_fly:dirs add again_fly:< ]



(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those after the moves)
[ was any:dirs ]
[ con:>/cut:> add any:> ]

(reconnect cuts)
[ was cut:> add con:> | was cut:< add con:< ]


(find which snake multiblocks are partially not over a hole)
[ was supported ]
[ snake no hole add supported ]
[ supported con:> | con:< add supported ]

(the rest fall into hole)
[ hole snake no supported add again_gravity ]
[ hole gpItem no again_fly:dirs now_fly:dirs supported add again_gravity ]

(fall into meta exit or fly back out)
[ player meta_exit any:< add again_exit | wall ]
[ player meta_exit any:< add now_fly:< | no wall ]
[ npc    meta_exit any:< add now_fly:< ] (just always leave again)


(reset player direction if not valid)
[ player snake no any:< ] [ was playerFacing:> add playerFacing:v ] 



(----FLY----)

(check what should fly this turn) 
(do something with each flying item now)

(hit snake end)
[ gpItem snake meta_exit/spawnpoint no any:> was now_fly:> ]
[ gpItem snake                      no any:> was now_fly:> add col_snake:> ] sfx7 (soft collision)

(hit wall/ block)
[ gpItem was now_fly:> add col_item:> maybeBounce | wall ] sfx0 (movement click)
[ gpItem was now_fly:> add col_item:> maybeBounce | snake no any:< add col_move:> ] sfx0

(hit other flying item/ stationary item)
[ gpItem was now_fly:> add again_fly:<            | gpItem was now_fly:<   add again_fly:> ] sfx0 (what about a perpendicular one? WIP)
[ gpItem was now_fly:> add col_item:> maybeBounce | gpItem is now_fly:dirs                 ] sfx0
[ gpItem was now_fly:> add col_item:> maybeBounce | gpItem no now_fly:dirs add again_fly:> ] sfx0

(identify tiles multiple items want to fly to)
[ was wantsToFlyTo:dirs ] (clean the markers from last time)
[ gpItem now_fly:> | add wantsToFlyTo:> ]
[ was wantsToFlyTo:> was wantsToFlyTo:</wantsToFlyTo:perpendicular ]
(bounce those items back instead)
[ gpItem was now_fly:> add again_fly:< | no wantsToFlyTo:> ]

(instead of colliding in place, player item will always bounce back)
[ player was col_item:> maybeBounce add again_fly:< ]
[ was maybeBounce ]

(default flying:)
(move to empty space)
[ was gpItem now_fly:> | no gpItem now_fly:dirs add gpItem again_fly:> ]


(----FLYING DONE----)

(player faces direction of flying)
[ player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(spread collisions ... note, this doesn't also show up on multipushed blocks)
[ col_move:dirs con:> | add col_move:dirs ] (WIP?)


(----QUEUE PUSHES FROM MOVERS----)

(find multiblocks that could move due to npc)
(if there was already an attempt that collided, the collision is cached.)
(it is updated if a relevant part of the collided blocks was moved.)
[ snake any:< npc no again_fly:< any:v any:^ any:> cached_col:> add again_move:>  ]



(----VISUAL ONLY----)

[ was tempVisualObjects ]

(show snake)
[ snake add vs_snake_base ]

(outline towards other connected snake part)
[ con:> add vs_con_lowest:> ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ cut:> | was stationary.wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(clean edge on sides without cut/con)
[ snake no any:> add vs_snake_edge:> ]

(add dot on rail ending in the center because it only goes to one neighbor)
[ snake no any:v any:^ any:> add vs_con_end ]

(npc at snake end)
[ npc snake any:< no any:v any:^ any:> add vs_npc:> ]
[ npc no vs_npc:dirs add vs_npc_off ]

(direction for eye)
[ playerFacing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( spawn point - show as filled when entering the level and hide the player )
[ spawnpoint any:> add vs_meta_pipe:< ]
[ again_spawn was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit - show as filled when exiting and hide the player)
[ meta_exit any:> add vs_meta_pipe:< ]
[ again_exit was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit arrow)
[ meta_exit any:< | wall add vs_meta_arrow:> ]


(----ACTIVATE COLLISION VARIANTS----)

(always animate items on a colliding block cell)
[ gpItem col_move:>/col_snake:> add col_item:> ]

(animate tiles in collision by replacing them with offset variants)
[ col_item:> was ball       add ball:> ] 
[ col_item:> was vs_npc_off add vs_npc_off:> ]

dirs [ col_item:> was vs_player:dirs add vs_player:dirs:> ]
dirs [ col_item:> was vs_npc:dirs    add vs_npc:dirs:> ]

[ col_move:> was vs_snake_base add vs_snake_base:> ] 
[ col_move:> was vs_con_end    add vs_con_end:> ] 

dirs [ col_move:> was vs_con_lowest:dirs       add vs_con_lowest:dirs:> ]
dirs [ col_move:> was con:dirs                 add con:dirs:> ]
dirs [ col_move:> was cut:dirs                 add cut:dirs:> ]
dirs [ col_move:> was vs_snake_edge:dirs       add vs_snake_edge:dirs:> ]
dirs [ col_move:> was vs_meta_pipe:dirs        add vs_meta_pipe:dirs:> ]
dirs [ col_move:> was vs_meta_pipe_closed:dirs add vs_meta_pipe_closed:dirs:> ]

(extend forwards)
[ col_snake:> is vs_con_end add vs_snake_col:> ] 


(----START AGAIN TURNS----)

(fall into hole/exit after shown over it)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_spawn ] -> sfx8 again (appear sound)

(fly again)
[ again_fly:> gpItem ] -> again

(move multiblock after there was space for it)
[ again_move:> ] -> again

(to go back from the collision animation to default state)
[ was col_move:dirs/col_item:dirs/col_snake:dirs add again_col ] again

(% endfilter %)