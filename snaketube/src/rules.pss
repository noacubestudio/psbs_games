(% filter relaxRules %)

(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(gravity)
[ hole again_gravity was gpGravity ]
[ hole again_gravity no again_fly:dirs was gpItem ]
[ was again_gravity ]

(queued moves)
[ was again_move:> add snakeMove:> ] (sfx7)
(queued flying)
[ any:v no any:> was again_fly:>    add now_fly:v ] (reorient in a pipe corner)
[ any:^ no any:> was again_fly:>    add now_fly:^ ] (reorient in a pipe corner)
dirs [           was again_fly:dirs add now_fly:dirs ]

(appearing from spawn)
[ con:>/cut:> was again_spawn add again_fly:> playerFacing:> ]
[ was again_spawn add playerFacing:right ] (wip, what is this?)

(win level)
[ was player was again_exit ] win

(end collision animation, swap tiles back)
(only for objects that don't get regenerated every turn anyway)
[ again_col ] [ was ball:offs add ball ]
dirs [ again_col ] [ was con:dirs:offs add con:dirs ]
dirs [ again_col ] [ was cut:dirs:offs add cut:dirs ]
[ was again_col ]


(----INIT----)
(do these at the start of the first turn, then never again)

(connect any snakes in level)
[ init ] [ snake no init_conBnotA/init_conAnotB init_noMoreCon cut:> add con:> | snake no init_conBnotA/init_conAnotB init_noMoreCon cut:< add con:< ]
[ init ] [ player was con:> | was con:< init_connectRules ]

(spawnpoints/meta_exit)
[ init ] [ spawnpoint/meta_exit no con:dirs cut:dirs add cut:> | no wall ]

(connect walls)
[ init ] [ wall add vs_wall_con:> ]
[ init ] [ wall was vs_wall_con:> | no wall ]

(wall edge)
[ init ] [ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]

[ init ] [ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(hole border)
[ init ] [ no hole add floor ]
[ init ] [ hole add vs_hole_edge:> | floor ]

(from a spawnpoint, the player appears)
[ init ] [ spawnpoint player add again_spawn ]

(remove markers only used for init)
[ init ] [ was init_conAnotB/init_conBnotA/init_noMoreCon ]

(remove init) 
[ was init ]



(----SET AT START OF ROUND ---)

(update group for each direction of both connections and cut ends of pipes)
[ was any:dirs ]
[ con:>/cut:> add any:> ]



(----PLAYER INPUT---)

(all moves start from within a tube)
(move to empty side starts flight, this same turn)
[ any:> was >.player add stationary.player now_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(move outside of snake starts flight, but only in backwards direction)
[ no any:dirs was >.player is vs_player:< add stationary.player now_fly:> ] [ was playerFacing:dirs add playerFacing:> ]
[ no any:dirs was >.player add stationary.player col_item:> ] sfx2

(move forward starts snake movement)
[ was >.player add stationary.player snakeMove:> ] [ was playerFacing:dirs add playerFacing:> ]

(if the player isn't at the end of a snake, block the move)
dirs [ any:> any:v was snakeMove:dirs add col_item:dirs ] sfx2
dirs [ any:> any:< was snakeMove:dirs add col_item:dirs ] sfx2



(----MOVE OBJECTS----)

( 
- a pipe end with a snakeMove moves as the head of the snake
- multiblocks and npcs in front get pushed
- the tail of the snake head follows - if it can not follow, for example because it got pushed or the head got pushed,
  the head will split.
- for any tiles that should do a normal move, collision in checked first so that ALL of them have to work out
- actual movement transfers everything in those tiles over, tile by tile
)

(remove temp markers from last time)
[ was wasMoved:dirs/wasSnakeMoved:dirs/wasItemMoved:dirs/follow:dirs/hasToSplit ]

[ snakeMove:> add itemMove:> ]

(the initial move can push blocks in front)
[ snakeMove:> | snake  add move:>     ]
[ snakeMove:> | gpItem add itemMove:> ]

(spread the move markers through any pushed blocks)
(can not spread from the snakeMove (head) to own tail since a push of the head only will ALWAYS split it)
[ move:> | snake add move:> ]
+ [ move:> no cut:> | gpItem add itemMove:> ]
+ [ itemMove:> | snake no cut:< add move:> ]
+ [ itemMove:> | gpItem no snake add itemMove:> ]
+ [ move:dirs con:> no snakeMove:dirs | con:< add move:dirs ] (through connections)
+ [ move:> gpItem add itemMove:> ]

(move fails entirely if something was pushed into non-moving obstacle:)

(initial collision: moving into non moving block)
[ was move:>/snakeMove:>  add col_move:>            | gplowcollide       no lowermovedirs ] nosave sfx2 (collision sound)
[ no snake was itemMove:> add col_move:> col_item:> | gplowcollide no cut:< lowermovedirs ] nosave sfx2 (collision sound)
(all blocked tiles will show bump animation, none of the moves happen)
(WIP: this fails if there is separate movement in the level in the same turn)
dirs [ col_move:> ] [ supported:> move:dirs/snakeMove:dirs add col_move:dirs ]
dirs [ col_move:> ] [ supported:> itemMove:dirs            add col_item:dirs ]
[ col_move:> ] [ was move:dirs/snakeMove:dirs/itemMove:dirs ]

(spread through tail also) (WIP, I think this does nothing since adding snake move)
dirs [ col_move:dirs con:> | con:< no col_move:dirs add col_move:dirs ]

(move can happen:)
(sound)
[ snakeMove:dirs ] -> sfx0 (sound)

(add temporary follow markers along the tail)
[ con:> add follow:> | con:< snakeMove:dirs ]
[ con:> no follow:dirs snakeMove:dirs add follow:> | con:< follow:dirs ]

(split head off by removing all follow markers on snake that follows the player if tiles are pushed sideways)
(also split if ONLY the front has a move marker)
[ move:perpendicular follow:> add hasToSplit ] 
[ no move:dirs add hasToSplit con:> | con:< move:dirs ]
[ hasToSplit con:> | con:< del follow:dirs add hasToSplit ]

(add snakeMove markers to snake)
[ was follow:> add snakeMove:> del move:dirs ]

(make sure all items are also moved)
[ move:>/snakeMove:> gpItem add itemMove:> ]

(actually do the movement)
(use markers to move all items in those tiles)

(items and their flying movement)
startloop
       [ itemMove:> was gpItem       | no itemMove:dirs add gpItem ]
  dirs [ itemMove:> was now_fly:dirs | no itemMove:dirs add now_fly:dirs ]
  [ was itemMove:>  no gpItem        | no itemMove:dirs add wasItemMoved:> ]
endloop

(snake parts)
startloop
  [     move:> was gpSnake | no lowermovedirs add gpSnake ]
  [ was move:>  no gpSnake | no lowermovedirs add wasMoved:>   ] sfx3 (pushed)
  [     snakeMove:> was gpSnake | no lowermovedirs add gpSnake ]
  [ was snakeMove:>  no gpSnake | no lowermovedirs add wasSnakeMoved:> ]
endloop

(item pushed sound)
[ wasItemMoved:dirs no wasSnakeMoved:dirs ] sfx3 (pushed)

(move done:)

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs                                      is con:< add correctConnectDir:< ]
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs no correctConnectDir:< was con:dirs add con:< add correctConnectDir:< ]
(if there is another connection or cut, make it face backwards again )
dirs [ wasSnakeMoved:< no correctConnectDir:dirs was con:dirs add con:> correctConnectDir:> ]
dirs [ wasSnakeMoved:<                           was cut:dirs add cut:> correctConnectDir:> ]
[ was correctConnectDir:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ wasMoved:dirs/wasSnakeMoved:dirs cut:> | cut:< no wasMoved:dirs wasSnakeMoved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ wasMoved:dirs/wasSnakeMoved:dirs was con:> add cut:> | no con:< ] sfx1
[ was con:> add cut:> | no con:< wasMoved:dirs/wasSnakeMoved:dirs ] sfx1

(moved item starts flying if there is space)
[ gpItem wasSnakeMoved:> wasItemMoved:dirs con:>/cut:> no again_fly:dirs add again_fly:> | no gpItem ]
[ gpItem wasItemMoved:> con:>/cut:>       no again_fly:dirs add again_fly:> ]
[ gpItem wasItemMoved:> cut:< con:v/cut:v no again_fly:dirs add again_fly:v ]
[ gpItem wasItemMoved:> cut:< con:^/cut:^ no again_fly:dirs add again_fly:^ ]
[ gpItem wasItemMoved:> no snake          no again_fly:dirs add again_fly:> ]
(immediately remove if it can't actually fly, only push)
[ gpItem wasItemMoved:> was again_fly:> | snake no cut:< con:< ]

(for snakeMoved, perpendicular is fine too, as in when a ball was dragged around a corner of the snake)
[ wasSnakeMoved:perpendicular wasItemMoved:dirs con:>/cut:> gpItem no again_fly:dirs add again_fly:> | no gpItem ]

(if cut was moved into item, the item moves the other way)
[ wasMoved:> cut:> gpItem no wasItemMoved:dirs again_fly:dirs add again_fly:< ]



(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those after the moves)
[ was any:dirs ]
[ con:>/cut:> add any:> ]

(reconnect cuts)
[ was cut:> add con:> | was cut:< add con:< ]


(find which snake multiblocks are partially not over a hole)
[ was supported ]
[ snake no hole add supported ]
[ supported con:> | con:< add supported ]

(the rest fall into hole)
[ hole snake no supported add again_gravity ]
[ hole gpItem no again_fly:dirs now_fly:dirs supported add again_gravity ]

(fall into meta exit)
[ player meta_exit add again_exit ]


(find sides towards which blocks are supported and not movable)
[ was supported:dirs ]
[ no wall | wall add supported:> ]
dirs [ con:> supported:dirs | con:< add supported:dirs ]
+ [ snake add supported:> | snake supported:> ]
+ [ snake no cut:> add supported:> | supported:> ]
+ [ gpItem add supported:> | supported:> no cut:< ]


(reset player direction if not valid)
[ player snake no any:< ] [ was playerFacing:> add playerFacing:v ] 



(----FLY----)

(check what should fly this turn) 
(do something with each flying item now)

(hit snake end)
[ gpItem snake meta_exit/spawnpoint no any:> was now_fly:> add col_move:> ]
[ gpItem snake                      no any:> was now_fly:> add col_snake:> ] sfx7 (soft collision)

(hit wall/ block)
[ gpItem was now_fly:> add col_item:> maybeBounce | wall ] sfx0 (movement click)
[ gpItem was now_fly:> add col_item:> maybeBounce | snake no any:< add col_move:> ] sfx0

(hit other flying item/ stationary item)
[ gpItem was now_fly:> add again_fly:<            | gpItem was now_fly:<   add again_fly:> ] sfx0 (what about a perpendicular one? WIP)
[ gpItem was now_fly:> add col_item:> maybeBounce | gpItem is now_fly:dirs                 ] sfx0
[ gpItem was now_fly:> add col_item:> maybeBounce | gpItem no now_fly:dirs add again_fly:> ] sfx0

(identify tiles multiple items want to fly to)
[ was wantsToFlyTo:dirs ] (clean the markers from last time)
[ gpItem now_fly:> | add wantsToFlyTo:> ]
[ was wantsToFlyTo:> was wantsToFlyTo:</wantsToFlyTo:perpendicular ]
(bounce those items back instead)
[ gpItem was now_fly:> add again_fly:< | no wantsToFlyTo:> ]

(instead of colliding in place, player item will always bounce back)
[ player was col_item:> maybeBounce add again_fly:< ]
[ was maybeBounce ]

(default flying:)
(move to empty space)
[ was gpItem now_fly:> | no gpItem now_fly:dirs add gpItem again_fly:> ]


(----FLYING DONE----)

(player faces direction of flying)
[ player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(spread collisions ... note, this doesn't also show up on multipushed blocks)
[ col_move:dirs con:> | add col_move:dirs ] (WIP?)


(----QUEUE PUSHES FROM MOVERS----)

(find multiblocks that could move due to npc)
[ snake any:< npc no again_fly:< any:v any:^ any:> add again_move:> | no wall add action.again_move:> ]

(prevent special cases of moving blocks)

(move markers facing each other)
[ was again_move:> | was again_move:< ]

(spread markers to check for overlapping directions, then remove all)
(action = temp in front of the actual pushers)
(directions = failed)
dirs [ con:> action.again_move:dirs | con:< add action.again_move:dirs ]
+ [ snake action.again_move:> | snake add action.again_move:> ]
+ [ gpItem action.again_move:> | snake no cut:< add action.again_move:> ]
+ [ snake/gpItem action.again_move:> no cut:> | gpItem add action.again_move:> ]
[ was action.again_move:> action.again_move:v add <.again_move:> ^.again_move:v ]
[ was action.again_move:> action.again_move:< add <.again_move:> >.again_move:< ]
[ was moving.again_move:> add <.again_move:> | <.again_move:> ] (spread result of overlap check)
[ was stationary.again_move:> | <.again_move:> ] (apply result of overlap check)
[ was again_move:> | supported:> ] (normal collision)
[ was moving.again_move:dirs ] (remove all temp)


(----VISUAL ONLY----)

[ was tempVisualObjects ]

(update edge of hole)
[ floor add vs_hole_edge:> | hole ] (not actually a temp object, but sometimes needs to get added)

(show snake)
[ snake add vs_snake_base ]

(outline towards other connected snake part)
[ con:> add vs_con_lowest:> ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ cut:> | was wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(clean edge on sides without cut/con)
[ snake no any:> add vs_snake_edge:> ]

(add dot on rail ending in the center because it only goes to one neighbor)
[ snake no any:v any:^ any:> add vs_con_end ]

(npc at snake end)
[ npc snake any:< no any:v any:^ any:> add vs_npc:> ]
[ npc no vs_npc:dirs add vs_npc_off ]

(direction for eye)
[ playerFacing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( spawn point - show as filled when entering the level and hide the player )
[ spawnpoint any:> add vs_meta_pipe:< ]
[ again_spawn was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit - show as filled when exiting and hide the player)
[ meta_exit any:> add vs_meta_pipe:< ]
[ again_exit was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit arrow)
[ meta_exit any:< | wall add vs_meta_arrow:> ]


(----ACTIVATE COLLISION VARIANTS----)

(always animate items on a colliding block cell)
[ gpItem col_move:>/col_snake:> add col_item:> ]

(animate tiles in collision by replacing them with offset variants)
[ col_item:> was ball       add ball:> ] 
[ col_item:> was vs_npc_off add vs_npc_off:> ]

dirs [ col_item:> was vs_player:dirs add vs_player:dirs:> ]
dirs [ col_item:> was vs_npc:dirs    add vs_npc:dirs:> ]

[ col_move:> was vs_snake_base add vs_snake_base:> ] 
[ col_move:> was vs_con_end    add vs_con_end:> ] 

dirs [ col_move:> was vs_con_lowest:dirs       add vs_con_lowest:dirs:> ]
dirs [ col_move:> was con:dirs                 add con:dirs:> ]
dirs [ col_move:> was cut:dirs                 add cut:dirs:> ]
dirs [ col_move:> was vs_snake_edge:dirs       add vs_snake_edge:dirs:> ]
dirs [ col_move:> was vs_meta_pipe:dirs        add vs_meta_pipe:dirs:> ]
dirs [ col_move:> was vs_meta_pipe_closed:dirs add vs_meta_pipe_closed:dirs:> ]

(extend forwards)
[ col_snake:> is vs_con_end add vs_snake_col:> ] 


(----START AGAIN TURNS----)

(fall into hole/exit after shown over it)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_spawn ] -> sfx8 again (appear sound)

(fly again)
[ again_fly:> gpItem ] -> again

(move multiblock after there was space for it)
[ again_move:> ] -> again

(to go back from the collision animation to default state)
[ was col_move:dirs/col_item:dirs/col_snake:dirs add again_col ] again

(% endfilter %)