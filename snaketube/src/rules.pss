(% filter relaxRules %)

(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(gravity)
[ hole again_gravity was gp_can_fall ]
[ hole again_gravity no again_fly:dirs was gp_items ]
[ was again_gravity ]

(queued moves)
[ was again_move:> add snake_move:> ]
(queued flying)
[ any:v no any:> was again_fly:>    add now_fly:v ] (reorient in a pipe corner)
[ any:^ no any:> was again_fly:>    add now_fly:^ ] (reorient in a pipe corner)
dirs [           was again_fly:dirs add now_fly:dirs ]

(appearing from spawn)
(add player in case they were removed before)
[ con:>/cut:> was again_spawn add again_fly:> player_facing:> player ]

(win level when exiting through meta exit)
[ meta_exit was player again_exit ] win
(if going back to spawn, player disappears and comes back later)
[ spawnpoint was player again_exit add again_spawn ]

(end collision animation, swap tiles back)
(only for objects that don't get regenerated every turn anyway)
[ again_col ] [ was ball:offs add ball ]
dirs [ again_col ] [ was con:dirs:offs add con:dirs ]
dirs [ again_col ] [ was cut:dirs:offs add cut:dirs ]
[ was again_col ]


(----INIT----)
(do these at the start of the first turn, then never again)

(connect any blocks in level)
[ init ] [ block no init_connect_only_b/init_connect_only_a init_dont_connect cut:> add con:> | block no init_connect_only_b/init_connect_only_a init_dont_connect cut:< add con:< ]
[ init ] [ player was con:> | was con:< init_connectRules ]

(spawnpoints/meta_exit)
[ init ] [ spawnpoint/meta_exit block no con:dirs cut:dirs add cut:> | no wall ]
(arrows)
[ init ] [ spawnpoint cut:< | wall add vs_meta_arrow:< ]
[ init ] [ meta_exit  cut:< | wall add vs_meta_arrow:> ]

(connect walls)
[ init ] [ wall add vs_wall_con:> ]
[ init ] [ wall was vs_wall_con:> | no wall ]

(wall edge)
[ init ] [ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]

[ init ] [ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(decoration)
[ init ] [ wall_deco_s was vs_wall_inner:> add vs_wall_deco_s:> ]
[ init ] [ wall_deco_m was vs_wall_inner:> add vs_wall_deco_m:> ]

(hole border)
[ init ] [ no hole add floor ]
[ init ] [ hole add vs_hole_edge_1:> vs_hole_edge_2:> | floor ]
[ init ] [ hole no vs_hole_edge_2:^ | was vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:^ | hole no vs_hole_edge_1:^ ]
[ init ] [ was vs_hole_edge_2:< vs_hole_edge_1:^ add vs_hole_outer_corner:^ ]
[ init ] [ hole no vs_hole_edge_1:> vs_hole_outer_corner:> | no hole add vs_hole_inner_corner:^ ]


(from a spawnpoint, the player appears)
[ init ] [ spawnpoint player add again_spawn ]

(remove markers only used for init)
[ init ] [ was init_connect_only_a/init_connect_only_b/init_dont_connect ]

(put screen_border in bottom left edge)
[ was stationary.init add action.init ] [ add screen_border ] (do once)
down [ init ] [ was screen_border | add screen_border ]

(remove init) 
[ was init ]



(----SET AT START OF ROUND ---)

(update group for each direction of both connections and cut ends of pipes)
[ was any:dirs ]
[ con:>/cut:> add any:> ]



(----PLAYER INPUT---)

(all moves start from within a tube)
(move to empty side starts flight, this same turn)
[ any:> was >.player add stationary.player now_fly:> ] [ was player_facing:dirs add player_facing:> ]

(move outside of block starts flight, but only in backwards direction)
[ vs_player:< no any:dirs was >.player add stationary.player now_fly:>  ] [ was player_facing:dirs add player_facing:> ]
[             no any:dirs was >.player add stationary.player col_item:> ] sfx2

(move forward starts block movement)
[ was >.player add stationary.player snake_move:> ] [ was player_facing:dirs add player_facing:> ]

(if the player isn't at the end of a block, block the move)
(dirs [ player any:> any:v was snake_move:dirs add col_item:dirs ] sfx2)
(dirs [ player any:> any:< was snake_move:dirs add col_item:dirs ] sfx2)



(----MOVE OBJECTS----)

( 
- a block with a snake_move moves as the head of a snake
- multiblocks and items in front get pushed
- tails and inhabitated heads of snakes can split and are not actually connected for pushing. the tail only follows via snake_move
- collisions or conflicts (multiple attempts to move into same tile) will prevent movement from happening, collision animation will show the problem.
- collisions are cashed so that auto-moving snakes don't try the same movement over and over and refreshed when needed.
- actual movement transfers everything in those tiles over, tile by tile
)

(remove temp markers from last time)
[ was was_pushed:dirs/was_snake_moved:dirs/was_item_pushed:dirs/follow:dirs/discard_move:dirs/discard_follow/try_move:dirs/try_follow:dirs/snake_source ]

(INITIAL MOVE)
(push block/ item in front)
[ snake_move:> | block    add push:> ]
[ snake_move:> | gp_items add item_push:> ]


(SPREAD PUSH MARKERS)

(push markers do not spread through connections if one side is a source of an active snake)
(detect these tiles first)
[ gp_items/pusher any:> no any:< any:v any:^ add snake_source ]

(items and blocks can push each other, unless there is an open side and they won't collide)
dirs [ push:dirs con:> no snake_source | con:< no snake_source add push:dirs ] (through multiblocks)
+ [ push:>          | block          add push:>      ] (block to block)
+ [ push:> no any:> | gp_items       add item_push:> ] (closed block to item outside)
+ [ item_push:>     | gp_items       add item_push:> ] (item to item)
+ [ item_push:>     | block no any:< add push:>      ] (item outside to closed block)
+ [ push:> gp_items   no any:< add item_push:> ] (item inside pushed block)
+ [ item_push:> block no any:> add push:>      ] (block around pushed item)

(count item pushes as any other push from now on)
[ no block was item_push:> add push:> ]
[ was item_push:> ]


(COLLISION)
[ was try_move:dirs ]
[ push:>/snake_move:> add try_move:> ]

(with wall)
[ try_move:> add col_move:> | wall ] sfx2 (collision sound)

(spread collision)
(backpropagate collision markers, these will animate with bounce)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:> | con:< add col_move:dirs ]

(forward propagate stopping movement on the blocks that weren't going to be pushed anyway)
(these won't show bump anim)
[ col_move:>     | try_move:> no col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:> | con:< add discard_move:dirs ]

(remember collisions and no longer check these for conflicts, as they already won't move)
[ col_move:> add col_cache:> del try_move:> push:> snake_move:> ]
[ discard_move:>             del try_move:> push:> snake_move:> ]
[ was discard_move:dirs ]


(CONFLICTS)

(only movements that didn't collide into wall are left)
(here we handle:
  - simultanious movement into the same spot
  - objects pushed into multiple directions at once
  - removing follow markers on pushed blocks since they separate from the snake head
)

(add follow markers inside moving snakes that point to the tile nearer to the front)
[ con:> snake_move:dirs | snake_move:dirs ] -> log connected adjacent snake movers!
[ con:> no follow:dirs snake_move:dirs add follow:> | con:< snake_move:dirs/follow:dirs ]

(potential conflict: object pushing into a single-tile moving block)
(if the moving block can actually move and doesn't have its own conflict, then the object will have room to move into it.)
(the try_follow:> markers are placed for now so this will be checked later)
(no pushing through the block head will happen if it can escape, and neither if the try_follow isn't working)
[ try_move:> no con:>            add col_move:>   | snake_move:<             add conflict_cache:> ] sfx2 (always has to collide)
[ try_move:> no con:> col_move:> add try_follow:> | snake_move:>             add discard_follow ]
[ try_move:> no con:> col_move:> add try_follow:> | snake_move:perpendicular add discard_move:> discard_follow ] (tail won't follow, if present)

(object pushing into tail of moving block)
(the tail will be pushed and not follow the block head)
[ try_move:> no con:> | follow:dirs add discard_follow ]

(conflict at empty tile, which is moved into from multiple directions)
[ try_move:> | no block gp_items add try_move_dest:> ]
[ try_move_dest:> try_move_dest:^ add conflict_cache:> conflict_cache:^ ]
[ try_move_dest:> try_move_dest:< add conflict_cache:> conflict_cache:< ]
[ add col_move:> | try_move_dest:> conflict_cache:> ] sfx2
[ was try_move_dest:dirs ]

(conflict at non-block-moving tile pushed into multiple directions)
[ try_move:> try_move:^ no follow:dirs snake_move:dirs add col_move:> col_move:^ ] sfx2
[ try_move:> try_move:< no follow:dirs snake_move:dirs add col_move:> col_move:< ] sfx2

(stop all pushing that can't happen due to a conflict)
(in front)
[ col_move:>     | try_move:> no snake_move:> col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no snake_move:> col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:> | con:< no snake_move:dirs add discard_move:dirs ]

(behind conflicts, spread collision. these tiles will show a collision animation.)
(try_follow will be cancelled)
(discard_follow will be spread, which can cause additional try_moves to fail, leading to more discard_follow)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:> | con:< add col_move:dirs ]
+ dirs [ follow:> add discard_follow | snake_move:dirs col_move:dirs ]
+ [ discard_follow con:> | con:< no snake_move:dirs add discard_follow ] (spread, including from block head)
+ [ snake_move:dirs was discard_follow ] (but don't leave on block head)
+ [ discard_follow was try_follow:dirs ]
+ [ try_follow:> add col_move:> | snake_move:>   col_move:dirs add conflict_cache:> ]
+ [ try_follow:> add col_move:> | discard_follow add conflict_cache:> ]

(cache these added collisions behind the conflicts)
[ try_move:> col_move:> add col_cache:> conflict_cache:> ]

(clear the movement)
[ col_move:> del push:>/snake_move:> ]
[ discard_move:> del push:>/snake_move:> ]
[ discard_follow del follow:dirs ]

(block can move)
[ follow:> add snake_move:> ]
[ snake_move:dirs del push:dirs ] (this should never be needed)

(don't visualize multi-directional collision)
[ was col_move:> col_move:v ]
[ was col_move:> col_move:< ]

(don't add to the undo queue if the player collided)
[ player col_move:> ] -> nosave



(MOVE CAN HAPPEN)
(sound)
[ snake_move:dirs ] -> sfx0 (sound)


(REFRESH COLLISION AND CONFLICT CACHE)

(refresh collision and conflict markers at push)
dirs [ push:>/snake_move:> col_cache:dirs      add refresh_cache:dirs ]
dirs [ push:>/snake_move:> conflict_cache:dirs add refresh_cache:dirs ]

(refresh collision marker behind already refreshed collision marker)
(refresh collision marker behind already refreshed conflict marker of any direction)
(refresh conflict marker in front of already refreshed collision marker)
  [ col_cache:> add refresh_cache:> | refresh_cache:> ]
+ [ col_cache:> add refresh_cache:> | refresh_cache:dirs conflict_cache:dirs ]
+ [ col_cache:> refresh_cache:> | conflict_cache:> add refresh_cache:> ]
+ dirs [ con:> refresh_cache:dirs | con:< add refresh_cache:dirs ] (spread through multiblocks)

[ refresh_cache:dirs del col_cache:dirs conflict_cache:dirs ]
[ was refresh_cache:dirs ]



(split movement into item and block movement again)
[ push:>/snake_move:> gp_items add item_push:> ]
[ gp_items no block was push:> ]


(actually do the movement)
(use markers to move all items in those tiles)

(items and their flying movement)
startloop
       [ item_push:> was gp_items     | no item_push:dirs add gp_items ]
  dirs [ item_push:> was now_fly:dirs | no item_push:dirs add now_fly:dirs ]
  [ was item_push:>  no gp_items      | no item_push:dirs add was_item_pushed:> ]
endloop

(block parts)
startloop
  [     push:> was gp_block | no gp_moving_blocks add gp_block ]
  [ was push:>  no gp_block | no gp_moving_blocks add was_pushed:> ] sfx3 (pushed)
  [     snake_move:> was gp_block | no gp_moving_blocks add gp_block ]
  [ was snake_move:>  no gp_block | no gp_moving_blocks add was_snake_moved:> ]
endloop

(item pushed sound)
[ was_item_pushed:dirs no was_snake_moved:dirs ] sfx3 (pushed)

(move done:)

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ was_snake_moved:< | was_snake_moved:dirs                                   is con:< add fixed_tail_con:< ]
dirs [ was_snake_moved:< | was_snake_moved:dirs no fixed_tail_con:< was con:dirs add con:< add fixed_tail_con:< ]
(cut at end faces backwards)
dirs [ was_snake_moved:< was cut:dirs add cut:> | no fixed_tail_con:< ]
(unchanged connections face backwards)
dirs [ was_snake_moved:< no fixed_tail_con:dirs was con:dirs add con:> fixed_tail_con:> ]
[ was fixed_tail_con:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ was_pushed:dirs/was_snake_moved:dirs cut:> | cut:< no was_pushed:dirs was_snake_moved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ was_pushed:dirs/was_snake_moved:dirs was con:> add cut:> | no con:< ] sfx1
[ was con:> add cut:> | no con:< was_pushed:dirs/was_snake_moved:dirs ] sfx1

(moved item starts flying if there is space)
[ gp_items was_snake_moved:> was_item_pushed:dirs con:>/cut:> no again_fly:dirs add again_fly:> | no gp_items ]
[ gp_items was_item_pushed:> con:>/cut:>       no again_fly:dirs add again_fly:> ]
[ gp_items was_item_pushed:> cut:< con:v/cut:v no again_fly:dirs add again_fly:v ]
[ gp_items was_item_pushed:> cut:< con:^/cut:^ no again_fly:dirs add again_fly:^ ]
[ gp_items was_item_pushed:> no block          no again_fly:dirs add again_fly:> ]
(immediately remove if it can't actually fly, only push)
[ gp_items was_item_pushed:> was again_fly:> | block no cut:< con:< ]
(prevent item flying into player in a closed block)
[ gp_items was_snake_moved:dirs was again_fly:> | block gp_items ]

(for snake_moved, perpendicular is fine too, as in when an item was dragged around a corner of the block)
[ was_snake_moved:perpendicular was_item_pushed:dirs con:>/cut:> gp_items no again_fly:dirs add again_fly:> | no gp_items ]

(if cut was moved into item, the item moves the other way)
[ was_pushed:> cut:> gp_items no was_item_pushed:dirs again_fly:dirs add again_fly:< ]



(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those after the moves)
[ was any:dirs ]
[ con:>/cut:> add any:> ]

(reconnect cuts)
[ was cut:> add con:> | was cut:< add con:< ]

(find which block multiblocks are partially not over a hole)
[ was supported ]
[ block no hole add supported ]
[ supported con:> | con:< add supported ]

(the rest fall into hole)
[ hole block no supported add again_gravity ]
[ hole gp_items no again_fly:dirs now_fly:dirs supported add again_gravity ]

(fall into meta pipes)
(don't fall in when currently spawning, about to fly out or flying out.)
[ player meta_exit/spawnpoint block no any:v any:^ any:< again_spawn now_fly:> again_fly:> add again_exit ]

(reset player direction if not valid)
[ player block no any:< ] [ was player_facing:> add player_facing:v ] 



(----FLY----)

(check what should fly this turn) 
(do something with each flying item now)

(hit block end)
[ player   block meta_exit/spawnpoint no any:> was now_fly:> ] (stop before falling in the next turn)
[ gp_items block                      no any:> was now_fly:> add col_head:> ] sfx7 (soft collision)

(hit wall/ block)
[ gp_items was now_fly:> add col_item:> try_bounce | wall ] sfx0 (movement click)
[ gp_items was now_fly:> add col_item:> try_bounce | block no any:< add col_move:> ] sfx0

(hit other flying item/ stationary item)
[ gp_items was now_fly:> add again_fly:<           | gp_items was now_fly:<   add again_fly:> ] sfx0 (what about a perpendicular one? WIP)
[ gp_items was now_fly:> add col_item:> try_bounce | gp_items is now_fly:dirs                 ] sfx0
[ gp_items was now_fly:> add col_item:> try_bounce | gp_items no now_fly:dirs add again_fly:> ] sfx0
[ gp_items was now_fly:> add col_item:> try_bounce | pusher                   add col_head:>  ] sfx7 (can't enter pusher pipe)

(identify tiles multiple items want to fly to)
[ was try_fly_dest:dirs ] (clean the markers from last time)
[ gp_items now_fly:> | add try_fly_dest:> ]
[ was try_fly_dest:> was try_fly_dest:</try_fly_dest:perpendicular ]
(bounce those items back instead)
[ gp_items was now_fly:> add again_fly:< | no try_fly_dest:> ]

(instead of colliding in place, player item will always bounce back)
[ player was col_item:> try_bounce add again_fly:< ]
[ was try_bounce ]

(default flying:)
(move to empty space)
[ was gp_items now_fly:> | no gp_items now_fly:dirs add gp_items again_fly:> ]


(----FLYING DONE----)

(player faces direction of flying)
[ player again_fly:> ] [ was player_facing:dirs add player_facing:> ]

(spread collisions ... note, this doesn't also show up on multipushed blocks)
dirs [ col_move:dirs con:> | add col_move:dirs ]

(----QUEUE PUSHES FROM MOVERS----)

(find multiblocks that could move due to npc)
(if there was already an attempt that collided, the collision is cached.)
(it is updated if a relevant part of the collided blocks was moved.)
[ block any:< npc no again_gravity again_fly:< any:v any:^ any:> col_cache:> conflict_cache:> add again_move:>  ]

(pushers work when they have at least one tail segment attached and move towards it)
[ was pusher_destination ]
[ block pusher con:> | add pusher_destination ]
[ block pusher_destination con:> | no pusher add pusher_destination ]
[ block pusher_destination no any:> any:^ any:v again_gravity col_cache:> conflict_cache:> add again_move:> ]
[ block pusher_destination    cut:>          no again_gravity col_cache:> conflict_cache:> add again_move:> ]

(----QUEUE PUSHES FROM PLAYER----)

(----END OF TURN----)



(----VISUAL ONLY----)

[ was gp_temporary_visuals ]

(show block)
[ block add vs_block_base ]

(outline towards other connected block part)
[ con:> add vs_con_lowest:> ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ cut:> | was stationary.wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(clean edge on sides without cut/con)
[ block no any:> add vs_block_edge:> ]

(add decoration to center of block with exactly one rail)
[ block any:> no any:v any:^ any:< add vs_con_end ]

(npc at block end)
[ npc block any:< no any:v any:^ any:> again_fly:< add vs_npc:> ]
[ npc no vs_npc:dirs add vs_npc_off ]

(pusher at block end, points at tail)
[ pusher block any:> no any:v any:^ any:< add vs_pusher:> ]

(direction for eye)
[ player_facing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( meta connections - show as filled when entering the level and hide the player )
[ spawnpoint/meta_exit any:> no any:v any:^ any:< add vs_meta_pipe:< ]
[ again_spawn/again_exit was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

(bigger player sprite if at end)
[ block no any:v any:^ any:> meta_exit spawnpoint was vs_player:> add vs_player_end:> ]


(----ACTIVATE COLLISION VARIANTS----)

(always animate items on a colliding block cell)
[ gp_items col_move:>/col_head:> add col_item:> ]

(animate tiles in collision by replacing them with offset variants)
[ col_item:> was ball       add ball:> ] 
[ col_item:> was vs_npc_off add vs_npc_off:> ]

dirs [ col_item:> was vs_player:dirs     add vs_player:dirs:> ]
dirs [ col_item:> was vs_player_end:dirs add vs_player_end:dirs:> ]
dirs [ col_item:> was vs_npc:dirs        add vs_npc:dirs:> ]

[ col_move:> was vs_block_base add vs_block_base:> ] 
[ col_move:> was vs_con_end    add vs_con_end:> ] 

dirs [ col_move:> was vs_con_lowest:dirs       add vs_con_lowest:dirs:> ]
dirs [ col_move:> was con:dirs                 add con:dirs:> ]
dirs [ col_move:> was cut:dirs                 add cut:dirs:> ]
dirs [ col_move:> was vs_block_edge:dirs       add vs_block_edge:dirs:> ]
dirs [ col_move:> was vs_meta_pipe:dirs        add vs_meta_pipe:dirs:> ]
dirs [ col_move:> was vs_meta_pipe_closed:dirs add vs_meta_pipe_closed:dirs:> ]
dirs [ col_move:> was vs_pusher:dirs           add vs_pusher:dirs:> ]

(extend forwards)
[ col_head:> is vs_con_end add vs_block_col:> ] 


(----START AGAIN TURNS----)

(fall into hole/exit after shown over it)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_spawn ] -> sfx8 again (appear sound)

(fly again)
[ again_fly:> gp_items ] -> again

(move multiblock after there was space for it)
[ again_move:> ] -> again

(to go back from the collision animation to default state)
[ was col_move:dirs/col_item:dirs/col_head:dirs add again_col ] again

(% endfilter %)