(% filter relaxRules %)

(----SUBROUTINES----)

(overall loop: turns start with init, player movement or because of an ongoing 'again' animation)
(visuals need to always be redrawn, so just check for 'background')
[ gp_again ] -> gosub handle_queued_from_last_turn
  [ init            ] -> gosub initialize_level 
  [ moving player   ] -> gosub handle_player_input
  [ gp_move_sources ] -> gosub handle_block_movement
  [ player          ] -> gosub handle_player_movement
  [ background      ] -> gosub redraw_visuals
[ gp_again ] -> again


(=====================================================================================)
subroutine handle_queued_from_last_turn
(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(delayed undo to show consequences of invalid action for a moment)
[ again_wait_undo ] -> undo
[ was again_undo add again_wait_undo ]

(after collision animation, swap tiles back that are not always redrawn)
dirs x [ again_col ] [ was con:x:dirs:offs add con:x:dirs ]
[ was again_col ]

(fall to other floor after being unsupported)
down [ again_gravity was block    | | | | | | | | | | | no wall add block block_fell del con:x:dirs ]
down [ again_gravity was gp_block | | | | | | | | | | | no wall add gp_block ]

(regular fall after being unsupported. queue undo if player falls in)
[ again_gravity was player add again_undo ]
[ again_gravity del block con:x:dirs ]
[ was again_gravity ] sfx4

(keep flying. change orientation if needed)
[ con:x:v no con:x:> was again_fly:> add now_fly:v ]
[ con:x:^ no con:x:> was again_fly:> add now_fly:^ ]
dirs [ was again_fly:dirs add now_fly:dirs ]

(appearing/re-appearing from spawn. uses a counter of 3 adjacent again_wait_entry to make the wait longer)
[ con:x:> was again_entry add again_fly:> player ] sfx8
[ room_entry no init was again_wait_entry add again_entry | was again_wait_entry | was again_wait_entry ]
right random [ again_wait_entry | no again_wait_entry add again_wait_entry ]

(fall into entry/ exit)
[ room_exit  was player again_exit ] win sfx4
[ room_entry was player again_exit add again_entry ] sfx4



(=====================================================================================)
subroutine initialize_level
(----INIT----)
(do these at the start of the first turn, then never again)

(set correct color palette)
[ init_theme:1 ] -> color_palette ega white #fff lightgray #F5B658 darkgray #894F2B black #15121c (fuse)
[ init_theme:2 ] -> color_palette ega white #fff lightgray #FD8274 darkgray #843043 black #15121c (turn)
[ init_theme:3 ] -> color_palette ega white #fff lightgray #B7D358 darkgray #356B38 black #15121c (move II)
[ init_theme:4 ] -> color_palette ega white #fff lightgray #5DD3F3 darkgray #226281 black #15121c (split)
[ init_theme:5 ] -> color_palette ega white #fff lightgray #98A7FF darkgray #4454A4 black #15121c (split II)
[ init_theme:6 ] -> color_palette ega white #fff lightgray #DF8EFF darkgray #65458C black #15121c (grow)
[ init_theme:7 ] -> color_palette ega white #fff lightgray #FF7FB7 darkgray #783466 black #15121c (grow II)
[ init_theme:8 ] -> color_palette ega white #fff lightgray #B0D194 darkgray #436557 black #15121c (close)

(show split guide when in the appropriate section)
[ init_theme:5 ] [ was screen_border:dirs add screen_border_split:dirs ]

(connect blocks)
[ was con:0:> add con:1:> | was con:0:< add con:1:< ]

(connect walls)
[ wall add vs_wall_con:> ]
[ wall was vs_wall_con:> | no wall ]

(wall edge)
[ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]
[ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(arrows to previous and next rooms)
[ room_entry con:x:< | wall add vs_room_arrow:< ]
[ room_exit  con:x:< | wall add vs_room_arrow:> ]

(decoration)
[ wall_deco     was vs_wall_inner:> add vs_wall_deco:> ]
[ wall_deco_big was vs_wall_inner:> add vs_wall_deco_big:> ]

(hole border)
[ hole add vs_hole_edge_1:> vs_hole_edge_2:> | no hole ]
[ hole no vs_hole_edge_2:^ | was vs_hole_edge_1:^ ]
[ was vs_hole_edge_2:^ | hole no vs_hole_edge_1:^ ]
[ was vs_hole_edge_2:< vs_hole_edge_1:^ add vs_hole_outer_corner:^ ]
[ hole no vs_hole_edge_1:> vs_hole_outer_corner:> | no hole add vs_hole_inner_corner:^ ]

(from a spawnpoint, the player appears)
(for testing: run_rules_on_level_start is not needed. initial move is removed.)
[ room_entry no again_wait_entry was player add stationary.player again_entry ]

(add a single tile where global level flags can be checked)
random [ init add global_flags_tile ]

(remove init) 
[ was init ]



(=====================================================================================)
subroutine handle_player_input
(----MENU INPUT----)

(title screen, place level exit on input to trigger win and sound)
[ was action player add stationary.player room_exit ] [ title_screen ]
[ was moving player add stationary.player           ] [ title_screen ]

(----PLAYER INPUT----)

(player input is received while not flying, so the player is in a block.)
(move to open side starts flight, this same turn)
[ con:x:> was >.player add stationary.player now_fly:> ]

(moving into another side starts snake movement)
[ was >.player add stationary.player player_move:> ]



(=====================================================================================)
subroutine handle_block_movement
(----MOVE OBJECTS----)

(a block with a player_move moves as the head of a snake )
(multiblocks in front get pushed )
(tail follows, also using player_move. if the tail got pushed by the snake itself, then it is treated as a connected block (split from head))
(collisions or conflicts (multiple attempts to move into same tile) will prevent movement from happening, collision animation will show the problem)
(when the movement planning is done, actual movement rules transfers everything in those tiles over, tile by tile)

(SPREAD PUSH MOVEMENT THROUGH BLOCKS)

(initial sources of block movement)
[ player_move:> | block add push:> ]
[ was block_fell ] (could have also triggered the subroutine, but only needed to update the connections between blocks.)

(pushes get spread to more blocks)
dirs [ push:dirs con:1:> no player | con:1:< no player add push:dirs ]
   + [ push:> | block add push:> ]


(COLLISION)

(most straightforward reason to block push: a wall is in the way.)
[ push:>/player_move:> add try_move:> ]
[ try_move:> add col_move:> | wall ] sfx2

(spread collision backwards - animate all this later)
[ try_move:> add col_move:> | col_move:> ]
+ dirs [ con:1:> col_move:dirs | con:1:< try_move:dirs no player add col_move:dirs ]

(forward propagate stopping movement on the blocks that weren't going to be pushed anyway)
(these won't show bump anim)
[ col_move:>     | try_move:> no col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< no player add discard_move:dirs ]

(remember collisions and no longer check these for conflicts, as they already won't move)
[ col_move:>     del try_move:> push:> player_move:> ]
[ discard_move:> del try_move:> push:> player_move:> ]
[ was discard_move:dirs ]


(CONFLICTS)

(only movements that didn't collide into wall are left)
(now handle:)
(- simultanious movement into the same spot)
(- objects pushed into multiple directions at once)
(- removing follow markers on pushed blocks since they separate from the snake head)

(add follow markers inside moving snakes that point to the tile nearer to the front)
[ con:1:> player_move:dirs | player_move:dirs ] -> log connected adjacent snake movers!
[ con:1:> no follow:dirs player_move:dirs add follow:> | con:1:< player_move:dirs/follow:dirs ]

(potential conflict: object pushing into a single-tile moving block)
(if the moving block can actually move and doesn't have its own conflict, then the object will have room to move into it.)
(the try_follow:> markers are placed for now so this will be checked later)
(no pushing through the block head will happen if it can escape, and neither if the try_follow isn't working)
[ try_move:> no con:1:>            add col_move:>   | player_move:< ] sfx2 (always has to collide)
[ try_move:> no con:1:> col_move:> add try_follow:> | player_move:> add discard_follow ]
(extra stuff for multiple push directions, WIP)
[ try_move:> no con:1:> col_move:>                  | player_move:v player add col_move:v ] (player pushing itself perpendicularily)
[ try_move:> no con:1:> col_move:>                  | player_move:^ player add col_move:^ ] (player pushing itself perpendicularily)
[ try_move:> no con:1:> col_move:> add try_follow:> | player_move:perpendicular add discard_move:> discard_follow ] (tail won't follow, if present)

(object pushing into tail of moving block)
(the entire tail will be pushed and not follow the try_move)
[ try_move:> no con:1:> | follow:dirs add discard_follow ]

(conflict at empty tile, which is moved into from multiple directions)
[ try_move:> | no block player add try_move_dest:> ]
[ add col_move:> | try_move_dest:> try_move_dest:perpendicular/try_move_dest:< ] sfx2
[ was try_move_dest:dirs ]

(conflict at non-block-moving tile pushed into multiple directions)
[ try_move:> try_move:^ no follow:dirs player_move:dirs add col_move:> col_move:^ ] sfx2
[ try_move:> try_move:< no follow:dirs player_move:dirs add col_move:> col_move:< ] sfx2

(stop all pushing that can't happen due to a conflict)
(in front)
[ col_move:>     | try_move:> no player_move:> col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no player_move:> col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< no player_move:dirs add discard_move:dirs ]

(note: the next section is done redundantly if there are multiple players and some had collision, not actually a conflict)
(so I added more 'no player' checks to the collision spread here)

(behind conflicts, spread collision. these tiles will show a collision animation.)
(try_follow will be cancelled)
(discard_follow will be spread, which can cause additional try_moves to fail, leading to more discard_follow)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:1:> | con:1:< no player add col_move:dirs ]
+ dirs [ player_move:dirs col_move:dirs | follow:< no player add discard_follow ]
+ [ discard_follow con:1:> | con:1:< no player add discard_follow ] (spread, including from block head)
+ [ player_move:dirs was discard_follow ] (but don't leave on block head)
+ [ discard_follow was try_follow:dirs ]
+ [ try_follow:> add col_move:> | player_move:> col_move:dirs ]
+ [ try_follow:> add col_move:> | discard_follow ]

(clear the movement)
[ col_move:> del push:>/player_move:> ]
[ discard_move:> del push:>/player_move:> ]

(block can move)
[ follow:> no discard_follow add player_move:> ]

(don't visualize multi-directional collision)
[ was col_move:> col_move:v ]
[ was col_move:> col_move:< ]

(don't add to the undo queue if player collided) (if another moved, skip this.)
[ player col_move:> ] [ was global_flags_tile add action.global_flags_tile ] (collision)
[ was action.global_flags_tile add global_flags_tile ] [ player_move:> ] (another player moved though)
[ was action.global_flags_tile add global_flags_tile ] nosave

(remove temp markers used in the movement planning, which is now over)
[ was follow:dirs/discard_move:dirs/discard_follow/try_move:dirs/try_follow:dirs ]


(MOVE CAN HAPPEN)
(sound)
[ player_move:dirs ] -> sfx0 (sound)

(actually do the movement)
(use markers to move all items in those tiles)
startloop
  [     push:> was gp_block | no push:dirs player_move:dirs add gp_block ]
  [ was push:>  no gp_block | no push:dirs player_move:dirs add was_pushed:> ] sfx3 (pushed)
  [     player_move:> was gp_block | no push:dirs player_move:dirs add gp_block ]
  [ was player_move:>  no gp_block | no push:dirs player_move:dirs add was_player_moved:> ]
endloop

(fix the connections of the turning pieces)
(former "forward" connection should now point at the front again)
(if that one already exist, just keep it)
dirs [ was_player_moved:< | was_player_moved:dirs                                     is con:1:< add fixed_tail_con:< ]
dirs [ was_player_moved:< | was_player_moved:dirs no fixed_tail_con:< was con:1:dirs add con:1:< add fixed_tail_con:< ]
(cut at end faces backwards)
dirs [ was_player_moved:< was con:0:dirs add con:0:> | no fixed_tail_con:< ]
(unchanged connections face backwards)
dirs [ was_player_moved:< no fixed_tail_con:dirs was con:1:dirs add con:1:> fixed_tail_con:> ]
[ was fixed_tail_con:dirs ]

(split/ connect)
[ was con:1:> add con:0:> | no con:1:< ] sfx1
[ was con:0:> add con:1:> | was con:0:< add con:1:< ] sfx5

(regenerate entry/ exit block)
[ gp_exits no block add block con:1:> | block add con:1:< ]

(remove markers for actually doing the movement)
[ was was_pushed:dirs/was_player_moved:dirs ]


(AFTER MOVE IS DONE)

(find which multiblocks are partially not over a hole)
[ was supported ]
[ block no hole add supported ]
[ supported con:1:> | con:1:< add supported ]

(the rest fall into hole)
[ hole block  no supported add again_gravity ]
[ hole player no again_fly:dirs now_fly:dirs supported add again_gravity ]



(=====================================================================================)
subroutine handle_player_movement

(fall into meta pipes)
(don't fall in when currently spawning, about to fly out or flying out.)
[ player gp_exits no con:x:v con:x:^ con:x:< again_entry again_wait_entry now_fly:> again_fly:> add again_exit ]


(FLY)

(hit block end. if there is an exit just silently stop for now)
[ player block gp_exits no con:x:> was now_fly:> ]
[ player block          no con:x:> was now_fly:> add col_head:> ] sfx7

(hit wall/ block)
[ player was now_fly:> add again_fly:< | wall ] sfx7
[ player was now_fly:> add again_fly:< | block no con:x:< add col_move:> ] sfx7

(hit other player)
[ player was now_fly:> add again_fly:< | player was now_fly:< add again_fly:> ] sfx7
[ player was now_fly:> add again_fly:< | player now_fly:dirs ] sfx7

(would hit other player - use markers to identify shared destination tile)
[ was try_fly_dest:dirs ]
[ player now_fly:> | add try_fly_dest:> ]
[ was try_fly_dest:> try_fly_dest:</try_fly_dest:perpendicular ]
[ player was now_fly:> add again_fly:< | no try_fly_dest:> ] sfx7

(hit nothing, just keep flying)
[ was player now_fly:> | no player now_fly:dirs add player again_fly:> ]

(if there's now_fly still, it's because the player is at the edge of the screen.)
(just make it disappear.)
[ was now_fly:> player ]


(FLYING DONE)

(spread collisions from bumping into items through flight ... unlike other collision this is only for the directly hit blocks)
(making it show up on all related tiles isn't necessary.)
dirs [ col_move:dirs con:1:> | add col_move:dirs ]



(=====================================================================================)
subroutine redraw_visuals
(----VISUAL ONLY----)

[ was gp_temporary_visuals ]

(finish drawing the blocks)
[ block add vs_block_base ]
[ block con:1:> add vs_con_sides:> ]
[ block no con:x:> add vs_block_edge:> ]

(endpoints)
[ block con:x:> no con:x:v con:x:^ con:x:< add vs_con_end ]
[ block gp_exits add vs_exit ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ con:0:> | was stationary.wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(do the same with hole edges)
[ vs_hole_inner_corner:> con:0:> add vs_hole_inner_corner_sharp:> ]
[ vs_hole_inner_corner:> con:0:^ add vs_hole_inner_corner_sharp:> ]

(reuse a fitting sprite here to show that holes lead to floor below)
up [ no wall | | | | | | | | | | | hole add vs_con_end ]

(player sprites while moving)
[ player again_fly:> add vs_player:> ]
[ player vs_exit again_fly:> con:x:> del vs_player:> add vs_player_entering:> ]
[ player again_exit                  del vs_player:> add vs_player_exiting ]
(player sprite at block end)
[ player vs_con_end con:x:< no again_fly:dirs gp_exits add vs_player_end:> ]

(if the player is leaving, animate the exit arrow)
[ vs_player_exiting ]            [ room_exit | vs_room_arrow:> add vs_blink_arrow:> ]
[ con:x:< again_fly:> gp_exits ] [ room_exit | vs_room_arrow:> add vs_blink_arrow:> ]

(ACTIVATE COLLISION VARIANTS)

(animate tiles in collision by replacing them with offset variants)
[ col_move:> was vs_block_base  add vs_block_base:> ] 
[ col_move:> was vs_con_end     add vs_con_end:> ] 
[ col_move:> was vs_exit        add vs_exit:> ] 
dirs [ col_move:> was vs_player:dirs     add vs_player:dirs:> ]
dirs [ col_move:> was vs_player_end:dirs add vs_player_end:dirs:> ]
dirs [ col_move:> was vs_con_sides:dirs  add vs_con_sides:dirs:> ]
dirs [ col_move:> was vs_block_edge:dirs add vs_block_edge:dirs:> ]
dirs x [ col_move:> was con:x:dirs add con:x:dirs:> ]

(extend forwards)
[ col_head:> is vs_con_end add vs_block_col:> ] 
[ col_head:> was vs_player_end:> add vs_player_end:>:> ]

(replace the markers with an again marker so these temporary animations can be removed again)
[ was col_move:dirs/col_head:dirs add again_col ]

(% endfilter %)