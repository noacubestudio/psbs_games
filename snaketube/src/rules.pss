(% filter relaxRules %)

(----SUBROUTINES----)

(gosub handle_queued_from_last_turn: turn continued from last turn without input)
(gosub initialize_level: once at init then never again)
(gosub redraw_visuals: always)

[ gp_again        ] -> gosub handle_queued_from_last_turn
[ init            ] -> gosub initialize_level 
[ moving player   ] -> gosub handle_player_input
[ gp_move_sources ] -> gosub handle_block_movement
[ player          ] -> gosub handle_player_movement
[ background      ] -> gosub redraw_visuals

(----START AGAIN TURNS----)

(fall into hole or exit, come out of entry, fly, end collision animation)
[ gp_again ] -> again


(=====================================================================================)
subroutine handle_queued_from_last_turn
(----AGAIN TURN----)
(do these in an again turn if the markers were placed in the previous turn)

(undo a turn.)
[ again_wait_undo ] -> undo
(need to wait a bit more first, looks better)
[ was again_undo add again_wait_undo ]

(after collision animation, swap some tiles back)
(all other animated tiles are reset every turn anyway)
dirs x [ again_col ] [ was con:x:dirs:offs add con:x:dirs ]
[ was again_col ]

(gravity)
(fall to floor)
down [ again_gravity was block    | | | | | | | | | | | no wall add block block_fell del con:x:dirs ]
down [ again_gravity was gp_block | | | | | | | | | | | no wall add gp_block ]
(regular fall)
[ again_gravity was player add again_undo ] (if player falls in, queue undo)
[ again_gravity del block con:x:dirs ]
[ was again_gravity ] sfx4 (falling sound)

(queued flying)
[ con:x:v no con:x:> was again_fly:> add now_fly:v ] (reorient in a pipe corner)
[ con:x:^ no con:x:> was again_fly:> add now_fly:^ ] (reorient in a pipe corner)
dirs [ was again_fly:dirs add now_fly:dirs ]

(appearing/re-appearing from spawn)
[ con:x:> was again_entry add again_fly:> player ] sfx8 (appear sound)
(waited for entry 3 times and did init)
[ room_entry no init was again_wait_entry add again_entry | was again_wait_entry | was again_wait_entry ]
(otherwise increment counter)
right random [ again_wait_entry | no again_wait_entry add again_wait_entry ]

(win level when exiting through meta exit)
[ room_exit  was player again_exit ] win sfx4 (falling sound)
(if going back to spawn, player disappears and comes back later)
[ room_entry was player again_exit add again_entry ] sfx4 (falling sound)



(=====================================================================================)
subroutine initialize_level
(----INIT----)
(do these at the start of the first turn, then never again)

(set correct color palette)
[ init_theme:1 ] -> color_palette ega white #fff lightgray #F5B658 darkgray #894F2B black #15121c (fuse)
[ init_theme:2 ] -> color_palette ega white #fff lightgray #FD8274 darkgray #843043 black #15121c (turn)
[ init_theme:3 ] -> color_palette ega white #fff lightgray #B7D358 darkgray #356B38 black #15121c (move II)
[ init_theme:4 ] -> color_palette ega white #fff lightgray #5DD3F3 darkgray #226281 black #15121c (split)
[ init_theme:5 ] -> color_palette ega white #fff lightgray #98A7FF darkgray #4454A4 black #15121c (split II)
[ init_theme:6 ] -> color_palette ega white #fff lightgray #DF8EFF darkgray #65458C black #15121c (grow)
[ init_theme:7 ] -> color_palette ega white #fff lightgray #FF7FB7 darkgray #783466 black #15121c (grow II)
[ init_theme:8 ] -> color_palette ega white #fff lightgray #B0D194 darkgray #436557 black #15121c (close)

(split guide)
[ init_theme:5 ] [ was screen_border:dirs add screen_border_split:dirs ]

(connect blocks)
[ was con:0:> add con:1:> | was con:0:< add con:1:< ]

(connect walls)
[ wall add vs_wall_con:> ]
[ wall was vs_wall_con:> | no wall ]

(wall edge)
[ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]
[ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(arrows to previous and next rooms)
[ room_entry con:x:< | wall add vs_room_arrow:< ]
[ room_exit  con:x:< | wall add vs_room_arrow:> ]

(decoration)
[ wall_deco     was vs_wall_inner:> add vs_wall_deco:> ]
[ wall_deco_big was vs_wall_inner:> add vs_wall_deco_big:> ]

(hole border)
[ hole add vs_hole_edge_1:> vs_hole_edge_2:> | no hole ]
[ hole no vs_hole_edge_2:^ | was vs_hole_edge_1:^ ]
[ was vs_hole_edge_2:^ | hole no vs_hole_edge_1:^ ]
[ was vs_hole_edge_2:< vs_hole_edge_1:^ add vs_hole_outer_corner:^ ]
[ hole no vs_hole_edge_1:> vs_hole_outer_corner:> | no hole add vs_hole_inner_corner:^ ]

(from a spawnpoint, the player appears)
[ room_entry no again_wait_entry was player add stationary.player again_entry ] (still works without run_rules_on_level_start for testing)

(add a single tile where global level flags can be checked)
random [ init add global_flags_tile ]

(remove init) 
[ was init ]



(=====================================================================================)
subroutine handle_player_input
(----MENU INPUT----)

(title screen, place level exit on input to trigger win and sound)
[ was action player add stationary.player room_exit ] [ title_screen ]
[ was moving player add stationary.player           ] [ title_screen ]

(----PLAYER INPUT----)

(player input is received while not flying, so the player is in a block.)
(move to open side starts flight, this same turn)
[ con:x:> was >.player add stationary.player now_fly:> ]

(moving into another side starts snake movement)
[ was >.player add stationary.player player_move:> ]



(=====================================================================================)
subroutine handle_block_movement
(----MOVE OBJECTS----)

(a block with a player_move moves as the head of a snake )
(multiblocks in front get pushed )
(tail follows, also using player_move. if the tail got pushed by the snake itself, then it is treated as a connected block (split from head))
(collisions or conflicts (multiple attempts to move into same tile) will prevent movement from happening, collision animation will show the problem)
(when the movement planning is done, actual movement rules transfers everything in those tiles over, tile by tile)

(SPREAD PUSH MOVEMENT THROUGH BLOCKS)

(initial source of block movement)
[ player_move:> | block add push:> ]
[ was block_fell ] (no need to do anything with this, just update connections)

(pushes get spread to more blocks)
dirs [ push:dirs con:1:> no player | con:1:< no player add push:dirs ] (through multiblocks)
+ [ push:> | block add push:> ] (block to block)


(COLLISION)

(used also for conflicts, but for now just check walls)
[ push:>/player_move:> add try_move:> ]
[ try_move:> add col_move:> | wall ] sfx2 (collision sound)

(spread collision backwards - animate all this later)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ con:1:> col_move:dirs | con:1:< try_move:dirs no player add col_move:dirs ]

(unused because push is always in one direction)
(+ [ con:1:> try_move:> add col_move:> | con:1:< col_move:dirs ] (face towards pushing end of pusher))

(forward propagate stopping movement on the blocks that weren't going to be pushed anyway)
(these won't show bump anim)
[ col_move:>     | try_move:> no col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< no player add discard_move:dirs ]

(remember collisions and no longer check these for conflicts, as they already won't move)
[ col_move:>     del try_move:> push:> player_move:> ]
[ discard_move:> del try_move:> push:> player_move:> ]
[ was discard_move:dirs ]


(CONFLICTS)

(only movements that didn't collide into wall are left)
(now handle:)
(simultanious movement into the same spot)
(objects pushed into multiple directions at once)
(removing follow markers on pushed blocks since they separate from the snake head)

(add follow markers inside moving snakes that point to the tile nearer to the front)
[ con:1:> player_move:dirs | player_move:dirs ] -> log connected adjacent snake movers!
[ con:1:> no follow:dirs player_move:dirs add follow:> | con:1:< player_move:dirs/follow:dirs ]

(potential conflict: object pushing into a single-tile moving block)
(if the moving block can actually move and doesn't have its own conflict, then the object will have room to move into it.)
(the try_follow:> markers are placed for now so this will be checked later)
(no pushing through the block head will happen if it can escape, and neither if the try_follow isn't working)
[ try_move:> no con:1:>            add col_move:>   | player_move:< ] sfx2 (always has to collide)
[ try_move:> no con:1:> col_move:> add try_follow:> | player_move:> add discard_follow ]
(extra stuff for multiple push directions, WIP)
[ try_move:> no con:1:> col_move:>                  | player_move:v player add col_move:v ] (player pushing itself perpendicularily)
[ try_move:> no con:1:> col_move:>                  | player_move:^ player add col_move:^ ] (player pushing itself perpendicularily)
[ try_move:> no con:1:> col_move:> add try_follow:> | player_move:perpendicular add discard_move:> discard_follow ] (tail won't follow, if present)

(object pushing into tail of moving block)
(the entire tail will be pushed and not follow the try_move)
[ try_move:> no con:1:> | follow:dirs add discard_follow ]

(conflict at empty tile, which is moved into from multiple directions)
[ try_move:> | no block player add try_move_dest:> ]
[ add col_move:> | try_move_dest:> try_move_dest:perpendicular/try_move_dest:< ] sfx2
[ was try_move_dest:dirs ]

(conflict at non-block-moving tile pushed into multiple directions)
[ try_move:> try_move:^ no follow:dirs player_move:dirs add col_move:> col_move:^ ] sfx2
[ try_move:> try_move:< no follow:dirs player_move:dirs add col_move:> col_move:< ] sfx2

(stop all pushing that can't happen due to a conflict)
(in front)
[ col_move:>     | try_move:> no player_move:> col_move:> add discard_move:> ]
[ discard_move:> | try_move:> no player_move:> col_move:> add discard_move:> ]
+ dirs [ discard_move:dirs con:1:> | con:1:< no player_move:dirs add discard_move:dirs ]

(note: the next section is done redundantly if there are multiple players and some had collision, not actually a conflict)
(so I added more 'no player' checks to the collision spread here)

(behind conflicts, spread collision. these tiles will show a collision animation.)
(try_follow will be cancelled)
(discard_follow will be spread, which can cause additional try_moves to fail, leading to more discard_follow)
  [ try_move:> add col_move:> | col_move:> ]
+ dirs [ col_move:dirs con:1:> | con:1:< no player add col_move:dirs ]
+ dirs [ player_move:dirs col_move:dirs | follow:< no player add discard_follow ]
+ [ discard_follow con:1:> | con:1:< no player add discard_follow ] (spread, including from block head)
+ [ player_move:dirs was discard_follow ] (but don't leave on block head)
+ [ discard_follow was try_follow:dirs ]
+ [ try_follow:> add col_move:> | player_move:> col_move:dirs ]
+ [ try_follow:> add col_move:> | discard_follow ]

(clear the movement)
[ col_move:> del push:>/player_move:> ]
[ discard_move:> del push:>/player_move:> ]

(block can move)
[ follow:> no discard_follow add player_move:> ]

(don't visualize multi-directional collision)
[ was col_move:> col_move:v ]
[ was col_move:> col_move:< ]

(don't add to the undo queue if player collided) (if another moved, skip this.)
[ player col_move:> ] [ was global_flags_tile add action.global_flags_tile ] (collision)
[ was action.global_flags_tile add global_flags_tile ] [ player_move:> ] (another player moved though)
[ was action.global_flags_tile add global_flags_tile ] nosave

(remove temp markers used in the movement planning, which is now over)
[ was follow:dirs/discard_move:dirs/discard_follow/try_move:dirs/try_follow:dirs ]


(MOVE CAN HAPPEN)
(sound)
[ player_move:dirs ] -> sfx0 (sound)

(actually do the movement)
(use markers to move all items in those tiles)
startloop
  [     push:> was gp_block | no push:dirs player_move:dirs add gp_block ]
  [ was push:>  no gp_block | no push:dirs player_move:dirs add was_pushed:> ] sfx3 (pushed)
  [     player_move:> was gp_block | no push:dirs player_move:dirs add gp_block ]
  [ was player_move:>  no gp_block | no push:dirs player_move:dirs add was_player_moved:> ]
endloop

(fix the connections of the turning pieces)
(former "forward" connection should now point at the front again)
(if that one already exist, just keep it)
dirs [ was_player_moved:< | was_player_moved:dirs                                     is con:1:< add fixed_tail_con:< ]
dirs [ was_player_moved:< | was_player_moved:dirs no fixed_tail_con:< was con:1:dirs add con:1:< add fixed_tail_con:< ]
(cut at end faces backwards)
dirs [ was_player_moved:< was con:0:dirs add con:0:> | no fixed_tail_con:< ]
(unchanged connections face backwards)
dirs [ was_player_moved:< no fixed_tail_con:dirs was con:1:dirs add con:1:> fixed_tail_con:> ]
[ was fixed_tail_con:dirs ]

(turn into cut if no longer has matching connection)
[ was con:1:> add con:0:> | no con:1:< ] sfx1

(connect newly adjacent cuts)
[ was con:0:> add con:1:> | was con:0:< add con:1:< ] sfx5

(regenerate entry/ exit block)
[ gp_exits no block add block con:1:> | block add con:1:< ]

(remove markers for actually doing the movement)
[ was was_pushed:dirs/was_player_moved:dirs ]


(AFTER MOVE IS DONE)

(find which multiblocks are partially not over a hole)
[ was supported ]
[ block no hole add supported ]
[ supported con:1:> | con:1:< add supported ]

(the rest fall into hole)
[ hole block  no supported add again_gravity ]
[ hole player no again_fly:dirs now_fly:dirs supported add again_gravity ]



(=====================================================================================)
subroutine handle_player_movement

(fall into meta pipes)
(don't fall in when currently spawning, about to fly out or flying out.)
[ player gp_exits no con:x:v con:x:^ con:x:< again_entry again_wait_entry now_fly:> again_fly:> add again_exit ]


(FLY)

(check what should fly this turn) 
(do something with each flying item now)

(hit block end)
[ player block gp_exits no con:x:> was now_fly:> ] (stop before falling in the next turn)
[ player block          no con:x:> was now_fly:> add col_head:> ] sfx7 (soft collision)

(hit wall/ block)
[ player was now_fly:> add col_item:> try_bounce | wall ] sfx7 (movement click)
[ player was now_fly:> add col_item:> try_bounce | block no con:x:< add col_move:> ] sfx7

(hit other player)
[ player was now_fly:> add again_fly:<           | player was now_fly:<   add again_fly:> ] sfx7 (what about a perpendicular one? WIP)
[ player was now_fly:> add col_item:> try_bounce | player is now_fly:dirs                 ] sfx7
[ player was now_fly:> add col_item:> try_bounce | player no now_fly:dirs add again_fly:> ] sfx7

(identify tiles multiple players want to fly to)
[ was try_fly_dest:dirs ] (clean the markers from last time)
[ player now_fly:> | add try_fly_dest:> ]
[ was try_fly_dest:> was try_fly_dest:</try_fly_dest:perpendicular ]
(bounce those items back instead)
[ player was now_fly:> add again_fly:< | no try_fly_dest:> ]

(instead of colliding in place, player item will always bounce back)
[ player was col_item:> try_bounce add again_fly:< ]
[ was try_bounce ]

(default flying:)
(move to empty space)
[ was player now_fly:> | no player now_fly:dirs add player again_fly:> ]

(if there's now_fly still, it's because the player is at the edge of the screen.)
(just make it disappear.)
[ was now_fly:> player ]


(FLYING DONE)

(spread collisions from bumping into items through flight ... unlike other collision this is only for the directly hit blocks)
dirs [ col_move:dirs con:1:> | add col_move:dirs ]



(=====================================================================================)
subroutine redraw_visuals
(----VISUAL ONLY----)

[ was gp_temporary_visuals ]

(show block)
[ block add vs_block_base ]

(outline towards other connected block part)
[ block con:1:> add vs_con_lowest:> ]

(clean edge on sides without connection)
[ block no con:x:> add vs_block_edge:> ]

(decoration on blocks with one connection)
[ block con:x:> no con:x:v con:x:^ con:x:< add vs_con_end ]

(exit block decoration)
[ block gp_exits add vs_exit ]

(show from room below)
up [ no wall | | | | | | | | | | | hole add vs_con_end ] (reusing a fitting sprite here)

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ con:0:> | was stationary.wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(do the same with hole edges)
[ vs_hole_inner_corner:> con:0:> add vs_hole_inner_corner_sharp:> ]
[ vs_hole_inner_corner:> con:0:^ add vs_hole_inner_corner_sharp:> ]

(player sprites while moving)
[ player again_fly:> add vs_player:> ]
[ player vs_exit again_fly:> con:x:> del vs_player:> add vs_player_entering:> ]
[ player again_exit                  del vs_player:> add vs_player_exiting ]
(player sprite at block end)
[ player vs_con_end con:x:< no again_fly:dirs again_exit add vs_player_end:> ]

(if the player is leaving, highlight the right way forward)
[ vs_player_exiting ]            [ room_exit | vs_room_arrow:> add vs_blink_arrow:> ]
[ con:x:< again_fly:> gp_exits ] [ room_exit | vs_room_arrow:> add vs_blink_arrow:> ]

(ACTIVATE COLLISION VARIANTS)

(always animate player on a colliding block cell)
[ player col_move:>/col_head:> add col_item:> ]

(animate tiles in collision by replacing them with offset variants)
[ col_move:> was vs_block_base  add vs_block_base:> ] 
[ col_move:> was vs_con_end     add vs_con_end:> ] 
[ col_move:> was vs_exit        add vs_exit:> ] 

dirs [ col_item:> was vs_player:dirs      add vs_player:dirs:> ]
dirs [ col_item:> was vs_player_end:dirs  add vs_player_end:dirs:> ]
dirs [ col_move:> was vs_con_lowest:dirs  add vs_con_lowest:dirs:> ]
dirs [ col_move:> was vs_block_edge:dirs  add vs_block_edge:dirs:> ]

dirs x [ col_move:> was con:x:dirs add con:x:dirs:> ]

(extend forwards)
[ col_head:> is vs_con_end add vs_block_col:> ] 

(can remove markers now, make sure the again turn to undo the visual is queued)
[ was col_move:dirs/col_item:dirs/col_head:dirs add again_col ]

(% endfilter %)