(% filter relaxRules %)

(----AGAIN TURN----)
(these are in a previously started again turn)

(stuff on snake falls into hole)
(ball and player fall into hole if not flying)
[ hole again_gravity was gpGravity ]
[ hole again_gravity no again_fly:dirs was gpItem ]
(replace snake and hole itself with floor)
[ was hole again_gravity snake add floor ]


(move multiblocks that can move on their own)
[ was again_move:> add snakeMove:> ] (sfx7)


(items appear from spawn)
[ con:>/cut:> was again_spawn add again_fly:> playerFacing:> ]
(no place to go? ... WIP, should later send it back)
[ was again_spawn add playerFacing:right ]

(player falls into meta exit, winning the level)
[ was player was again_exit ] win


(revert collision)
(swap the shifted collision anim objects out with the regular ones)
(other objects get regenerated every turn anyway & don't need to be swapped back here)
[ again_col ] [ was ball:offs add ball ]
dirs [ again_col ] [ was con:dirs:offs add con:dirs ]
dirs [ again_col ] [ was cut:dirs:offs add cut:dirs ]

[ was again_col ]


(----INIT----)
(do these at the start of the turn, then remove the init marker.)

(connect any snakes in level)
[ init ] [ snake no init_conBnotA/init_conAnotB init_noMoreCon cut:> add con:> | snake no init_conBnotA/init_conAnotB init_noMoreCon cut:< add con:< ]
[ init ] [ player was con:> | was con:< init_connectRules ]

(spawnpoints/meta_exit)
[ init ] [ spawnpoint/meta_exit no con:dirs cut:dirs add cut:> | no wall ]

(connect walls)
[ init ] [ wall add vs_wall_con:> ]
[ init ] [ wall was vs_wall_con:> | no wall ]

(wall edge)
[ init ] [ wall add vs_wall_inner:> vs_wall_edge:> del vs_outside | no wall ]
[ init ] [ vs_wall_inner:v | wall no vs_wall_inner:v add vs_wall_inner_corner:> del vs_outside ]

[ init ] [ vs_wall_inner:^ add vs_wall_edge_2:^ | vs_wall_inner:^ add vs_wall_edge_1:^ ]

(hole border)
[ init ] [ no hole add floor ]
[ init ] [ hole add vs_hole_edge:> | floor ]

(from a spawnpoint, the player appears)
[ init ] [ spawnpoint player add again_spawn ]

(remove markers only used for init)
[ init ] [ was init_conAnotB/init_conBnotA/init_noMoreCon ]

(remove init) 
[ was init ]



(----SET AT START OF ROUND ---)

(any markers, these are used to sometimes ignore which kind of connections are actually present)
(but record the directions of connection for later in the turn)
[ was any:dirs ]
[ con:>/cut:> add any:> ]



(----PLAYER INPUT---)

(all moves start from within a tube)
(move to empty side starts flight)
[ any:> was >.player add stationary.player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(move outside of snake starts flight, but only in backwards direction)
[ no any:dirs was >.player is vs_player:< add stationary.player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]
[ no any:dirs was >.player add stationary.player col_item:> ] sfx2

(move forward starts snake movement)
[ was >.player add stationary.player snakeMove:> ] [ was playerFacing:dirs add playerFacing:> ]

(if the player isn't at the end of a snake, block the move)
dirs [ any:> any:v was snakeMove:dirs add col_item:dirs ] sfx2
dirs [ any:> any:< was snakeMove:dirs add col_item:dirs ] sfx2


(----FLY----)

(reorient flying direction based on pipe around)
(the stationary makes sure they can only do this once)
(if anything else, like pushing leads to flying, on the initial turn this isn't done...)
(WIP: is that part needed?)
[ any:v no any:> was stationary.again_fly:> add v.again_fly:v ]
[ any:^ no any:> was stationary.again_fly:> add ^.again_fly:^ ]

(reset temporary marker)
[ was again_fly:dirs add stationary.again_fly:dirs ]


(check what should happen this turn) 
(if there's a match, skip all remaining cases using a temporary action marker)

(if flying into snake end, stop and collide)
[ gpItem snake no any:> was stationary.again_fly:> add col_snake:> col_item:> ] sfx7 (soft collision)

(if flying into wall or snake side, stop)
[ was stationary.again_fly:> is player/ball/npc add col_item:> | wall ] sfx0 (movement click)
[ was stationary.again_fly:> is player/ball/npc add col_item:> | snake no any:< add col_snake:> ] sfx0 (movement click)

(if flying into another flying object, both repel)
[ gpItem was stationary.again_fly:> add action.again_fly:< | gpItem was stationary.again_fly:< add action.again_fly:> ] sfx7 (soft coll)

(if flying into stationary object at snake end, that one steers)
[ gpItem was stationary.again_fly:> add col_item:> | snake gpItem no any:> any:perpendicular add snakeMove:> ] sfx0 (movement click)

(if flying into stationary object that could move, that one flies)
[ gpItem was stationary.again_fly:> add col_item:> | gpItem add action.again_fly:> ] sfx0 (movement click)

(if flying into empty space that another object wants to fly into)
(first place directional markers in the empty space)
[ gpItem stationary.again_fly:> | add wantsToFlyTo:> ]
(remove the markers if there is overlap)
[ was wantsToFlyTo:> was wantsToFlyTo:</wantsToFlyTo:perpendicular ]
(now check for moving into empty space with the marker missing)
[ gpItem was stationary.again_fly:> add action.again_fly:> | no wantsToFlyTo:> ]
(clear the markers)
[ was wantsToFlyTo:dirs ]

(if flying into any other tile, just move one tile)
[ was gpItem stationary.again_fly:> | add gpItem action.again_fly:> ]



(----FLYING DONE----)

(reset temporary markers)
[ was again_fly:dirs add stationary.again_fly:dirs ]

(if flying, set player facing)
[ player again_fly:> ] [ was playerFacing:dirs add playerFacing:> ]

(spread collisions)
[ col_snake:dirs con:> | add col_snake:dirs ]



(----MOVE OBJECTS----)

( 
- a pipe end with a snakeMove moves as the head of the snake
- multiblocks and npcs in front get pushed
- the tail of the snake head follows - if it can not follow, for example because it got pushed or the head got pushed,
  the head will split.
- for any tiles that should do a normal move, collision in checked first so that ALL of them have to work out
- actual movement transfers everything in those tiles over, tile by tile
)

(remove temp markers from last time)
[ was wasMoved:dirs/wasSnakeMoved:dirs/wasItemMoved:dirs/follow:dirs/hasToSplit ]

[ snakeMove:> add itemMove:> ]

(the initial move can push blocks in front)
[ snakeMove:> | snake  add move:>     ]
[ snakeMove:> | gpItem add itemMove:> ]

(spread the move markers through any pushed blocks)
(can not spread from the snakeMove (head) to own tail since a push of the head only will ALWAYS split it)
[ move:> | snake add move:> ]
+ [ move:> no cut:> | gpItem add itemMove:> ]
+ [ itemMove:> | snake no cut:< add move:> ]
+ [ itemMove:> | npc no snake add itemMove:> ]
+ [ move:dirs con:> no snakeMove:dirs | con:< add move:dirs ] (through connections)
+ [ move:> gpItem add itemMove:> ]

(move fails entirely if something was pushed into non-moving obstacle:)

(show collision animation and cancel any actual movement if collided)
[ was move:>/snakeMove:>  add col_snake:>            | gplowcollide       no lowermovedirs ] nosave sfx2 (collision sound)
[ no snake was itemMove:> add col_snake:> col_item:> | gplowcollide no cut:< lowermovedirs ] nosave sfx2 (collision sound)

dirs [ col_snake:> ] [ was move:dirs/snakeMove:dirs add col_snake:dirs ]
dirs [ col_snake:> ] [ was itemMove:dirs            add col_item:dirs ]

(to also spread through tail)
dirs [ col_snake:dirs con:> | con:< no col_snake:dirs add col_snake:dirs ]

(move can happen:)
(sound)
[ snakeMove:dirs ] -> sfx0 (sound)

(add temporary follow markers along the tail)
[ con:> add follow:> | con:< snakeMove:dirs ]
[ con:> no follow:dirs snakeMove:dirs add follow:> | con:< follow:dirs ]

(split head off by removing all follow markers on snake that follows the player if tiles are pushed sideways)
(also split if ONLY the front has a move marker)
[ move:perpendicular follow:> add hasToSplit ] 
[ no move:dirs add hasToSplit con:> | con:< move:dirs ]
[ hasToSplit con:> | con:< del follow:dirs add hasToSplit ]

(add snakeMove markers to snake)
[ was follow:> add snakeMove:> del move:dirs ]

(make sure all items are also moved)
[ move:>/snakeMove:> gpItem add itemMove:> ]

(actually do the movement)
(use markers to move all items in those tiles)

startloop
  [     itemMove:> was gpItem | no itemMove:dirs add gpItem         ]
  [ was itemMove:>  no gpItem | no itemMove:dirs add wasItemMoved:> ]
endloop

(snake parts)
startloop
  [     move:> was gpSnake | no lowermovedirs add gpSnake ]
  [ was move:>  no gpSnake | no lowermovedirs add wasMoved:>   ] sfx3 (pushed)
  [     snakeMove:> was gpSnake | no lowermovedirs add gpSnake ]
  [ was snakeMove:>  no gpSnake | no lowermovedirs add wasSnakeMoved:> ]
endloop

(item pushed sound)
[ wasItemMoved:dirs no wasSnakeMoved:dirs ] sfx3 (pushed)

(move done:)

(fix the connections of the turning pieces )
(former "forward" connection should now point at the front again )
(if that one already exist, just keep it )
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs                                      is con:< add correctConnectDir:< ]
dirs [ wasSnakeMoved:< | wasSnakeMoved:dirs no correctConnectDir:< was con:dirs add con:< add correctConnectDir:< ]
(if there is another connection or cut, make it face backwards again )
dirs [ wasSnakeMoved:< no correctConnectDir:dirs was con:dirs add con:> correctConnectDir:> ]
dirs [ wasSnakeMoved:<                           was cut:dirs add cut:> correctConnectDir:> ]
[ was correctConnectDir:dirs ]

(a moved cut next to a stationary one will make a sound because it reconnects )
[ wasMoved:dirs/wasSnakeMoved:dirs cut:> | cut:< no wasMoved:dirs wasSnakeMoved:dirs] -> sfx5

(new cuts are created, this makes a splitting sound )
[ wasMoved:dirs/wasSnakeMoved:dirs was con:> add cut:> | no con:< ] sfx1
[ was con:> add cut:> | no con:< wasMoved:dirs/wasSnakeMoved:dirs ] sfx1

(moved item starts flying if there is space)
[ gpItem wasSnakeMoved:> wasItemMoved:dirs con:>/cut:> no again_fly:dirs add again_fly:> | no gpItem ]
[ gpItem wasItemMoved:> con:>/cut:> no again_fly:dirs add again_fly:> ]
[ gpItem wasItemMoved:> cut:< con:v/cut:v no again_fly:dirs add again_fly:v ]
[ gpItem wasItemMoved:> cut:< con:^/cut:^ no again_fly:dirs add again_fly:^ ]
[ gpItem wasItemMoved:> no snake          no again_fly:dirs add again_fly:> ]
(immediately remove if it can't actually fly, only push)
[ gpItem wasItemMoved:> was again_fly:> | snake no cut:< con:< ]

(for snakeMoved, perpendicular is fine too, as in when a ball was dragged around a corner of the snake)
[ wasSnakeMoved:perpendicular wasItemMoved:dirs con:>/cut:> gpItem no again_fly:dirs add again_fly:> | no gpItem ]

(if cut was moved into item, the item moves the other way)
[ wasMoved:> cut:> gpItem no wasItemMoved:dirs again_fly:dirs add again_fly:< ]



(----AFTER MOVE IS DONE----)

("any" markers indicate every kind of connection, reset those for the next turn)
[ was any:dirs ]
[ con:>/cut:> add any:> ]

(reconnect cuts)
[ was cut:> add con:> | was cut:< add con:< ]

(find which snake multiblocks are partially not over a hole)
[ was supported ]
[ snake no hole add supported ]
[ supported con:> | con:< add supported ]

(the rest fall into hole)
[ snake no supported add again_gravity ]

(items fall into meta exit)
[ gpItem meta_exit add again_exit ]

(reset player direction if not valid)
[ player snake no any:< ] [ was playerFacing:> add playerFacing:v ] 

(find multiblocks that could move due to npc)
[ snake any:< npc no any:v any:^ any:> add again_move:> | no gplowcollide ]

(----VISUAL ONLY----)

[ was tempVisualObjects ]

(update edge of hole)
[ floor add vs_hole_edge:> | hole ] (not actually a temp object, but sometimes needs to get added)

(show snake)
[ snake add vs_snake_base ]

(outline towards other connected snake part)
[ con:> add vs_con_lowest:> ]

(make wall corners temporarily sharper to match presence of a block with a sharp corner)
[ cut:> | was wall add <.wall ]
[ vs_wall_inner_corner:^ add vs_wall_inner_corner_sharp:^ | v.wall ]
[ v.wall | vs_wall_inner_corner:> add vs_wall_inner_corner_sharp:> ]
[ was moving.wall add wall ]

(clean edge on sides without cut/con)
[ snake no any:> add vs_snake_edge:> ]

(add dot on rail ending in the center because it only goes to one neighbor)
[ snake no any:v any:^ any:> add vs_con_end ]

(npc at snake end)
[ npc snake any:< no any:v any:^ any:> add vs_npc:> ]
[ npc no vs_npc:dirs add vs_npc_off ]

(direction for eye)
[ playerFacing:> ] [ player add vs_player:> ] 
[ player no vs_player:dirs add vs_player:right ]

( spawn point - show as filled when entering the level and hide the player )
[ spawnpoint con:>/cut:> add vs_meta_pipe:< ]
[ again_spawn was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

( meta exit - show as filled when exiting and hide the player)
[ meta_exit  con:>/cut:> add vs_meta_pipe:< ]
[ again_exit was vs_meta_pipe:> add vs_meta_pipe_closed:> del vs_player:dirs ]

(animate tiles in collision by replacing them with offset variants)
[ col_item:> was ball       add ball:> ] 
[ col_item:> was vs_npc_off add vs_npc_off:> ]

[ col_snake:> was vs_snake_base add vs_snake_base:> ] 
[ col_snake:> was vs_con_end    add vs_con_end:> ] 

dirs [ col_item:> was vs_player:dirs add vs_player:dirs:> ]
dirs [ col_item:> was vs_npc:dirs    add vs_npc:dirs:> ]

dirs [ col_snake:> was vs_con_lowest:dirs       add vs_con_lowest:dirs:> ]
dirs [ col_snake:> was con:dirs                 add con:dirs:> ]
dirs [ col_snake:> was cut:dirs                 add cut:dirs:> ]
dirs [ col_snake:> was vs_snake_edge:dirs       add vs_snake_edge:dirs:> ]
dirs [ col_snake:> was vs_meta_pipe:dirs        add vs_meta_pipe:dirs:> ]
dirs [ col_snake:> was vs_meta_pipe_closed:dirs add vs_meta_pipe_closed:dirs:> ]



(----START AGAIN TURNS----)

(fall into hole/exit after shown over it)
[ again_gravity/again_exit ] -> sfx4 again (falling sound)

(come out of spawn)
[ again_spawn ] -> sfx8 again (appear sound)

(fly again)
[ again_fly:> gpItem ] -> again

(move multiblock after there was space for it)
[ again_move:> ] -> again

(to go back from the collision animation to default state)
[ was col_snake:dirs add again_col ] again
[ was col_item:dirs  add again_col ] again

(% endfilter %)